{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pixi-live2d-display \u00b6 \u4e2d\u6587\u7248readme Live2D integration for PixiJS v5. This project aims to be a universal Live2D framework on the web platform. While the official Live2D framework is just complex and problematic, this project has rewritten it to unify and simplify the APIs, which allows you to control the Live2D models on a high level without the need to learn how the internal system works. More details can be found in the Documentation . Features \u00b6 Supports all versions of Live2D models Supports PIXI.RenderTexture and PIXI.Filter Pixi-style transform APIs: position, scale, rotation, skew, anchor Automatic interactions: focusing, hit-testing Enhanced motion reserving logic compared to the official framework Loading from uploaded files / zip files (experimental) Fully typed - we all love types! Requirement \u00b6 PixiJS: > 5.2.0 (lower versions were not tested) Browser: WebGL, ES6 Demo \u00b6 Basic demo Interaction demo Render texture & filter demo Live2D Viewer Online Cubism \u00b6 Cubism is the name of Live2D SDK. There are so far three versions of it: Cubism 2.1, Cubism 3 and Cubism 4; where Cubism 4 is backward-compatible with Cubism 3 models. This plugin supports all variants of Live2D models by using Cubism 2.1 and Cubism 4. Cubism Core \u00b6 Before using the plugin, you'll need to include the Cubism runtime library, aka Cubism Core. For Cubism 4, you need live2dcubismcore.min.js that can be extracted from the Cubism 4 SDK , or be referred by a direct link ( however the direct link is quite unreliable, don't use it in production! ). For Cubism 2.1, you need live2d.min.js . It's no longer downloadable from the official site since 2019/9/4 , but can be found here , and with a CDN link that you'll probably need. Individual Bundles \u00b6 The plugin provides individual bundles for each Cubism version to reduce your app's size when you just want to use one of the versions. Specifically, there are cubism2.js and cubism4.js for respective runtime, along with an index.js that includes both of them. Note that if you want both the Cubism 2.1 and Cubism 4 support, use index.js , but not the combination of cubism2.js and cubism4.js . To make it clear, here's how you would use these files: Use cubism2.js + live2d.min.js to support Cubism 2.1 models Use cubism4.js + live2dcubismcore.min.js to support Cubism 3 and Cubism 4 models Use index.js + live2d.min.js + live2dcubismcore.min.js to support all versions of models Installation \u00b6 Via npm \u00b6 npm install pixi-live2d-display import { Live2DModel } from 'pixi-live2d-display' ; // if only Cubism 2.1 import { Live2DModel } from 'pixi-live2d-display/lib/cubism2' ; // if only Cubism 4 import { Live2DModel } from 'pixi-live2d-display/lib/cubism4' ; Via CDN \u00b6 < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/index.min.js\" ></ script > <!-- if only Cubism 2.1 --> < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/cubism2.min.js\" ></ script > <!-- if only Cubism 4 --> < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/cubism4.min.js\" ></ script > In this way, all the exported members are available under PIXI.live2d namespace, such as PIXI.live2d.Live2DModel . Usage \u00b6 Basic \u00b6 import * as PIXI from 'pixi.js' ; // with a global PIXI variable, this plugin can automatically take // the needed functionality from it, such as window.PIXI.Ticker window . PIXI = PIXI ; // accordingly, here we should use require() to import the module, // instead of the import statement because the latter will be hoisted // over the above assignment when compiling the script const { Live2DModel } = require ( 'pixi-live2d-display' ); async function main () { const app = new PIXI . Application ({ view : document . getElementById ( 'canvas' ) }); const model = await Live2DModel . from ( 'shizuku.model.json' ); app . stage . addChild ( model ); // transforms model . x = 100 ; model . y = 100 ; model . rotation = Math . PI ; model . skew . x = Math . PI ; model . scale . set ( 2 , 2 ); model . anchor . set ( 0.5 , 0.5 ); // interaction model . on ( 'hit' , hitAreas => { if ( hitAreas . includes ( 'body' )) { model . motion ( 'tap_body' ); } }); } Package importing \u00b6 Pixi provides separate packages, which allows you to import only the necessary packages rather than the entire bundle. In this case, you'll need to manually register the optional components if you want to make use of their features. import { Application } from '@pixi/app' ; import { Renderer } from '@pixi/core' ; import { Ticker , TickerPlugin } from '@pixi/ticker' ; import { InteractionManager } from '@pixi/interaction' ; import { Live2DModel } from 'pixi-live2d-display' ; // register the Ticker to support automatic updating of Live2D models Application . registerPlugin ( TickerPlugin ); Live2DModel . registerTicker ( Ticker ); // register the InteractionManager to support automatic interaction of Live2D models Renderer . registerPlugin ( 'interaction' , InteractionManager ); async function main () { const app = new Application ({ view : document . getElementById ( 'canvas' ) }); const model = await Live2DModel . from ( 'shizuku.model.json' ); app . stage . addChild ( model ); } The example Live2D models, Shizuku (Cubism 2.1) and Haru (Cubism 4), are redistributed under Live2D's Free Material License .","title":"Introduction"},{"location":"#pixi-live2d-display","text":"\u4e2d\u6587\u7248readme Live2D integration for PixiJS v5. This project aims to be a universal Live2D framework on the web platform. While the official Live2D framework is just complex and problematic, this project has rewritten it to unify and simplify the APIs, which allows you to control the Live2D models on a high level without the need to learn how the internal system works. More details can be found in the Documentation .","title":"pixi-live2d-display"},{"location":"#features","text":"Supports all versions of Live2D models Supports PIXI.RenderTexture and PIXI.Filter Pixi-style transform APIs: position, scale, rotation, skew, anchor Automatic interactions: focusing, hit-testing Enhanced motion reserving logic compared to the official framework Loading from uploaded files / zip files (experimental) Fully typed - we all love types!","title":"Features"},{"location":"#requirement","text":"PixiJS: > 5.2.0 (lower versions were not tested) Browser: WebGL, ES6","title":"Requirement"},{"location":"#demo","text":"Basic demo Interaction demo Render texture & filter demo Live2D Viewer Online","title":"Demo"},{"location":"#cubism","text":"Cubism is the name of Live2D SDK. There are so far three versions of it: Cubism 2.1, Cubism 3 and Cubism 4; where Cubism 4 is backward-compatible with Cubism 3 models. This plugin supports all variants of Live2D models by using Cubism 2.1 and Cubism 4.","title":"Cubism"},{"location":"#cubism-core","text":"Before using the plugin, you'll need to include the Cubism runtime library, aka Cubism Core. For Cubism 4, you need live2dcubismcore.min.js that can be extracted from the Cubism 4 SDK , or be referred by a direct link ( however the direct link is quite unreliable, don't use it in production! ). For Cubism 2.1, you need live2d.min.js . It's no longer downloadable from the official site since 2019/9/4 , but can be found here , and with a CDN link that you'll probably need.","title":"Cubism Core"},{"location":"#individual-bundles","text":"The plugin provides individual bundles for each Cubism version to reduce your app's size when you just want to use one of the versions. Specifically, there are cubism2.js and cubism4.js for respective runtime, along with an index.js that includes both of them. Note that if you want both the Cubism 2.1 and Cubism 4 support, use index.js , but not the combination of cubism2.js and cubism4.js . To make it clear, here's how you would use these files: Use cubism2.js + live2d.min.js to support Cubism 2.1 models Use cubism4.js + live2dcubismcore.min.js to support Cubism 3 and Cubism 4 models Use index.js + live2d.min.js + live2dcubismcore.min.js to support all versions of models","title":"Individual Bundles"},{"location":"#installation","text":"","title":"Installation"},{"location":"#via-npm","text":"npm install pixi-live2d-display import { Live2DModel } from 'pixi-live2d-display' ; // if only Cubism 2.1 import { Live2DModel } from 'pixi-live2d-display/lib/cubism2' ; // if only Cubism 4 import { Live2DModel } from 'pixi-live2d-display/lib/cubism4' ;","title":"Via npm"},{"location":"#via-cdn","text":"< script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/index.min.js\" ></ script > <!-- if only Cubism 2.1 --> < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/cubism2.min.js\" ></ script > <!-- if only Cubism 4 --> < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/cubism4.min.js\" ></ script > In this way, all the exported members are available under PIXI.live2d namespace, such as PIXI.live2d.Live2DModel .","title":"Via CDN"},{"location":"#usage","text":"","title":"Usage"},{"location":"#basic","text":"import * as PIXI from 'pixi.js' ; // with a global PIXI variable, this plugin can automatically take // the needed functionality from it, such as window.PIXI.Ticker window . PIXI = PIXI ; // accordingly, here we should use require() to import the module, // instead of the import statement because the latter will be hoisted // over the above assignment when compiling the script const { Live2DModel } = require ( 'pixi-live2d-display' ); async function main () { const app = new PIXI . Application ({ view : document . getElementById ( 'canvas' ) }); const model = await Live2DModel . from ( 'shizuku.model.json' ); app . stage . addChild ( model ); // transforms model . x = 100 ; model . y = 100 ; model . rotation = Math . PI ; model . skew . x = Math . PI ; model . scale . set ( 2 , 2 ); model . anchor . set ( 0.5 , 0.5 ); // interaction model . on ( 'hit' , hitAreas => { if ( hitAreas . includes ( 'body' )) { model . motion ( 'tap_body' ); } }); }","title":"Basic"},{"location":"#package-importing","text":"Pixi provides separate packages, which allows you to import only the necessary packages rather than the entire bundle. In this case, you'll need to manually register the optional components if you want to make use of their features. import { Application } from '@pixi/app' ; import { Renderer } from '@pixi/core' ; import { Ticker , TickerPlugin } from '@pixi/ticker' ; import { InteractionManager } from '@pixi/interaction' ; import { Live2DModel } from 'pixi-live2d-display' ; // register the Ticker to support automatic updating of Live2D models Application . registerPlugin ( TickerPlugin ); Live2DModel . registerTicker ( Ticker ); // register the InteractionManager to support automatic interaction of Live2D models Renderer . registerPlugin ( 'interaction' , InteractionManager ); async function main () { const app = new Application ({ view : document . getElementById ( 'canvas' ) }); const model = await Live2DModel . from ( 'shizuku.model.json' ); app . stage . addChild ( model ); } The example Live2D models, Shizuku (Cubism 2.1) and Haru (Cubism 4), are redistributed under Live2D's Free Material License .","title":"Package importing"},{"location":"README.zh/","text":"pixi-live2d-display \u00b6 \u4e3a PixiJS v5 \u63d0\u4f9b\u7684 Live2D \u63d2\u4ef6 \u6b64\u9879\u76ee\u65e8\u5728\u6210\u4e3a web \u5e73\u53f0\u4e0a\u7684\u901a\u7528 Live2D \u6846\u67b6\u3002\u7531\u4e8e Live2D \u7684\u5b98\u65b9\u6846\u67b6\u975e\u5e38\u590d\u6742\u4e14\u4e0d\u53ef\u9760\uff0c\u8fd9\u4e2a\u9879\u76ee\u5df2\u5c06\u5176\u91cd\u5199\u4ee5\u63d0\u4f9b\u7edf\u4e00\u4e14\u7b80\u5355\u7684 API\uff0c\u4f7f\u4f60\u53ef\u4ee5\u4ece\u8f83\u9ad8\u7684\u5c42\u6b21\u6765\u63a7\u5236 Live2D \u6a21\u578b\u800c\u65e0\u9700\u4e86\u89e3\u5176\u5185\u90e8\u7684\u5de5\u4f5c\u539f\u7406 \u7279\u6027 \u00b6 \u652f\u6301\u6240\u6709\u7248\u672c\u7684 Live2D \u6a21\u578b \u652f\u6301 PIXI.RenderTexture \u548c PIXI.Filter Pixi \u98ce\u683c\u7684\u53d8\u6362 API\uff1aposition, scale, rotation, skew, anchor \u81ea\u52a8\u4ea4\u4e92\uff1a\u9f20\u6807\u8ddf\u8e2a, \u70b9\u51fb\u547d\u4e2d\u68c0\u6d4b \u6bd4\u5b98\u65b9\u6846\u67b6\u66f4\u597d\u7684\u52a8\u4f5c\u9884\u7ea6\u903b\u8f91 \u4ece\u4e0a\u4f20\u7684\u6587\u4ef6\u6216 zip \u6587\u4ef6\u4e2d\u52a0\u8f7d (\u5b9e\u9a8c\u6027\u529f\u80fd) \u5b8c\u5584\u7684\u7c7b\u578b\u5b9a\u4e49 - \u6211\u4eec\u90fd\u559c\u6b22\u7c7b\u578b\uff01 \u8981\u6c42 \u00b6 PixiJS\uff1a> 5.2.0 \uff08\u66f4\u4f4e\u7684\u7248\u672c\u5c1a\u672a\u6d4b\u8bd5\uff09 \u6d4f\u89c8\u5668\uff1aWebGL\uff0c ES6 \u793a\u4f8b \u00b6 \u57fa\u7840\u793a\u4f8b \u4ea4\u4e92\u793a\u4f8b \u6e32\u67d3\u7eb9\u7406\u4e0e\u6ee4\u955c\u793a\u4f8b Live2D Viewer Online \u6587\u6863 \u00b6 Wiki API \u6587\u6863 Cubism \u00b6 Cubism \u662f Live2D SDK \u7684\u540d\u79f0\uff0c\u76ee\u524d\u67093\u4e2a\u7248\u672c\uff1aCubism 2.1\u3001Cubism 3\u3001Cubism 4\uff0c\u5176\u4e2d Cubism 4 \u53ef\u4ee5\u4e0e Cubism 3 \u7684\u6a21\u578b\u517c\u5bb9 \u8be5\u63d2\u4ef6\u4f7f\u7528 Cubism 2.1 \u548c Cubism 4\uff0c\u4ece\u800c\u652f\u6301\u6240\u6709\u7248\u672c\u7684 Live2D \u6a21\u578b Cubism Core \u00b6 \u5728\u4f7f\u7528\u8be5\u63d2\u4ef6\u4e4b\u524d\uff0c\u4f60\u9700\u8981\u52a0\u8f7d Cubism \u8fd0\u884c\u65f6\uff0c\u4e5f\u5c31\u662f Cubism Core Cubism 4 \u9700\u8981\u52a0\u8f7d live2dcubismcore.min.js \uff0c\u53ef\u4ee5\u4ece Cubism 4 SDK \u91cc\u89e3\u538b\u51fa\u6765\uff0c\u6216\u8005\u76f4\u63a5\u5f15\u7528 \u8fd9\u4e2a\u94fe\u63a5 \uff08 \u94fe\u63a5\u5076\u5c14\u4f1a\u6302\u6389\uff0c\u4e0d\u8981\u5728\u751f\u4ea7\u7248\u672c\u4e2d\u4f7f\u7528\uff01 \uff09 Cubism 2.1 \u9700\u8981\u52a0\u8f7d live2d.min.js \uff0c \u4ece 2019/9/4 \u8d77 \uff0c\u5b98\u65b9\u5df2\u7ecf\u4e0d\u518d\u63d0\u4f9b\u8be5\u7248\u672c SDK \u7684\u4e0b\u8f7d\uff0c\u4f46\u662f\u53ef\u4ee5\u4ece \u8fd9\u91cc \u627e\u5230\uff0c\u4ee5\u53ca\u4f60\u5927\u6982\u60f3\u8981\u7684 CDN \u94fe\u63a5 \u5355\u72ec\u7684\u6253\u5305\u6587\u4ef6 \u00b6 \u8be5\u63d2\u4ef6\u4e3a\u6bcf\u4e2a Cubism \u7248\u672c\u63d0\u4f9b\u4e86\u5355\u72ec\u7684\u6253\u5305\u6587\u4ef6\uff0c\u4ece\u800c\u5728\u4f60\u53ea\u60f3\u4f7f\u7528\u5176\u4e2d\u4e00\u4e2a\u7248\u672c\u7684\u65f6\u5019\u51cf\u5c11\u9700\u8981\u52a0\u8f7d\u6587\u4ef6\u7684\u5927\u5c0f\u3002 \u5177\u4f53\u6765\u8bf4\uff0c\u4e3a\u4e24\u79cd\u7248\u672c\u5206\u522b\u63d0\u4f9b\u4e86 cubism2.js \u548c cubism4.js \uff0c\u4ee5\u53ca\u4e00\u4e2a\u540c\u65f6\u5305\u542b\u4e86\u4e24\u79cd\u7248\u672c\u7684 index.js \u6ce8\u610f\uff0c\u5982\u679c\u4f60\u60f3\u540c\u65f6\u652f\u6301 Cubism 2.1 \u548c Cubism 4 \u7684\u8bdd\uff0c\u8bf7\u4f7f\u7528 index.js \uff0c \u800c\u4e0d\u8981\u540c\u65f6\u4f7f\u7528 cubism2.js \u548c cubism4.js \u4e3a\u4e86\u66f4\u660e\u786e\u4e00\u70b9\uff0c\u8fd9\u91cc\u5217\u51fa\u4f7f\u7528\u8fd9\u4e9b\u6587\u4ef6\u7684\u65b9\u6cd5\uff1a \u4f7f\u7528 cubism2.js + live2d.min.js \u4ee5\u652f\u6301 Cubism 2.1 \u6a21\u578b \u4f7f\u7528 cubism4.js + live2dcubismcore.min.js \u4ee5\u652f\u6301 Cubism 3 \u548c Cubism 4 \u6a21\u578b \u4f7f\u7528 index.js + live2d.min.js + live2dcubismcore.min.js \u4ee5\u652f\u6301\u6240\u6709\u7248\u672c\u7684\u6a21\u578b \u5b89\u88c5 \u00b6 \u901a\u8fc7 npm \u00b6 npm install pixi-live2d-display import { Live2DModel } from 'pixi-live2d-display' ; // \u5982\u679c\u53ea\u9700\u8981 Cubism 2.1 import { Live2DModel } from 'pixi-live2d-display/lib/cubism2' ; // \u5982\u679c\u53ea\u9700\u8981 Cubism 4 import { Live2DModel } from 'pixi-live2d-display/lib/cubism4' ; \u901a\u8fc7 CDN \u00b6 < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/index.min.js\" ></ script > <!-- \u5982\u679c\u53ea\u9700\u8981 Cubism 2.1 --> < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/cubism2.min.js\" ></ script > <!-- \u5982\u679c\u53ea\u9700\u8981 Cubism 4 --> < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/cubism4.min.js\" ></ script > \u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u52a0\u8f7d\u7684\u8bdd\uff0c\u6240\u6709\u6210\u5458\u90fd\u4f1a\u88ab\u5bfc\u51fa\u5230 PIXI.live2d \u547d\u540d\u7a7a\u95f4\u4e0b\uff0c\u6bd4\u5982 PIXI.live2d.Live2DModel \u4f7f\u7528 \u00b6 \u57fa\u7840 \u00b6 import * as PIXI from 'pixi.js' ; // \u5982\u679c\u5b58\u5728\u5168\u5c40\u7684 PIXI \u53d8\u91cf\uff0c\u8be5\u63d2\u4ef6\u4f1a\u81ea\u52a8\u5f15\u7528\u6240\u9700\u7684\u529f\u80fd\uff0c\u6bd4\u5982 window.PIXI.Ticker window . PIXI = PIXI ; // \u6240\u4ee5\uff0c\u8fd9\u91cc\u9700\u8981\u4f7f\u7528 require() \u6765\u5bfc\u5165\u6a21\u5757\u800c\u4e0d\u662f import \u8bed\u53e5\uff0c\u56e0\u4e3a\u540e\u8005\u4f1a\u5728\u7f16\u8bd1\u65f6\u88ab // \u63d0\u5347\uff08hoist\uff09\u5230\u4e0a\u9762\u8d4b\u503c\u8bed\u53e5\u7684\u524d\u9762 const { Live2DModel } = require ( 'pixi-live2d-display' ); async function main () { const app = new PIXI . Application ({ view : document . getElementById ( 'canvas' ), autoStart : true }); const model = await Live2DModel . from ( 'shizuku.model.json' ); app . stage . addChild ( model ); // \u53d8\u6362 model . x = 100 ; model . y = 100 ; model . rotation = Math . PI ; model . skew . x = Math . PI ; model . scale . set ( 2 , 2 ); model . anchor . set ( 0.5 , 0.5 ); // \u4ea4\u4e92 model . on ( 'hit' , hitAreas => { if ( hitAreas . includes ( 'body' )) { model . motion ( 'tap_body' ); } }); } \u5305\u5bfc\u5165 \u00b6 Pixi \u63d0\u4f9b\u4e86\u5355\u72ec\u7684\u5305\u4ee5\u652f\u6301\u6309\u9700\u5bfc\u5165\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u60f3\u8981\u4f7f\u7528\u67d0\u4e9b\u529f\u80fd\uff0c\u5219\u9700\u8981\u624b\u52a8\u6ce8\u518c\u76f8\u5e94\u7684\u7ec4\u4ef6 import { Application } from '@pixi/app' ; import { Renderer } from '@pixi/core' ; import { Ticker , TickerPlugin } from '@pixi/ticker' ; import { InteractionManager } from '@pixi/interaction' ; import { Live2DModel } from 'pixi-live2d-display' ; // \u6ce8\u518c Ticker \u4ee5\u652f\u6301 Live2D \u6a21\u578b\u7684\u81ea\u52a8\u66f4\u65b0 Application . registerPlugin ( TickerPlugin ); Live2DModel . registerTicker ( Ticker ); // \u6ce8\u518c InteractionManager \u4ee5\u652f\u6301 Live2D \u6a21\u578b\u7684\u81ea\u52a8\u4ea4\u4e92 Renderer . registerPlugin ( 'interaction' , InteractionManager ); async function main () { const app = new Application (); const model = await Live2DModel . from ( 'shizuku.model.json' ); app . stage . addChild ( model ); } \u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u8bbf\u95ee Wiki \uff08\u6682\u65e0\u4e2d\u6587\u7ffb\u8bd1\uff09 \u793a\u4f8b\u7684 Live2D \u6a21\u578b Shizuku (Cubism 2.1) \u548c Haru (Cubism 4) \u9075\u5b88 Live2D \u7684 Free Material License","title":"pixi-live2d-display"},{"location":"README.zh/#pixi-live2d-display","text":"\u4e3a PixiJS v5 \u63d0\u4f9b\u7684 Live2D \u63d2\u4ef6 \u6b64\u9879\u76ee\u65e8\u5728\u6210\u4e3a web \u5e73\u53f0\u4e0a\u7684\u901a\u7528 Live2D \u6846\u67b6\u3002\u7531\u4e8e Live2D \u7684\u5b98\u65b9\u6846\u67b6\u975e\u5e38\u590d\u6742\u4e14\u4e0d\u53ef\u9760\uff0c\u8fd9\u4e2a\u9879\u76ee\u5df2\u5c06\u5176\u91cd\u5199\u4ee5\u63d0\u4f9b\u7edf\u4e00\u4e14\u7b80\u5355\u7684 API\uff0c\u4f7f\u4f60\u53ef\u4ee5\u4ece\u8f83\u9ad8\u7684\u5c42\u6b21\u6765\u63a7\u5236 Live2D \u6a21\u578b\u800c\u65e0\u9700\u4e86\u89e3\u5176\u5185\u90e8\u7684\u5de5\u4f5c\u539f\u7406","title":"pixi-live2d-display"},{"location":"README.zh/#_1","text":"\u652f\u6301\u6240\u6709\u7248\u672c\u7684 Live2D \u6a21\u578b \u652f\u6301 PIXI.RenderTexture \u548c PIXI.Filter Pixi \u98ce\u683c\u7684\u53d8\u6362 API\uff1aposition, scale, rotation, skew, anchor \u81ea\u52a8\u4ea4\u4e92\uff1a\u9f20\u6807\u8ddf\u8e2a, \u70b9\u51fb\u547d\u4e2d\u68c0\u6d4b \u6bd4\u5b98\u65b9\u6846\u67b6\u66f4\u597d\u7684\u52a8\u4f5c\u9884\u7ea6\u903b\u8f91 \u4ece\u4e0a\u4f20\u7684\u6587\u4ef6\u6216 zip \u6587\u4ef6\u4e2d\u52a0\u8f7d (\u5b9e\u9a8c\u6027\u529f\u80fd) \u5b8c\u5584\u7684\u7c7b\u578b\u5b9a\u4e49 - \u6211\u4eec\u90fd\u559c\u6b22\u7c7b\u578b\uff01","title":"\u7279\u6027"},{"location":"README.zh/#_2","text":"PixiJS\uff1a> 5.2.0 \uff08\u66f4\u4f4e\u7684\u7248\u672c\u5c1a\u672a\u6d4b\u8bd5\uff09 \u6d4f\u89c8\u5668\uff1aWebGL\uff0c ES6","title":"\u8981\u6c42"},{"location":"README.zh/#_3","text":"\u57fa\u7840\u793a\u4f8b \u4ea4\u4e92\u793a\u4f8b \u6e32\u67d3\u7eb9\u7406\u4e0e\u6ee4\u955c\u793a\u4f8b Live2D Viewer Online","title":"\u793a\u4f8b"},{"location":"README.zh/#_4","text":"Wiki API \u6587\u6863","title":"\u6587\u6863"},{"location":"README.zh/#cubism","text":"Cubism \u662f Live2D SDK \u7684\u540d\u79f0\uff0c\u76ee\u524d\u67093\u4e2a\u7248\u672c\uff1aCubism 2.1\u3001Cubism 3\u3001Cubism 4\uff0c\u5176\u4e2d Cubism 4 \u53ef\u4ee5\u4e0e Cubism 3 \u7684\u6a21\u578b\u517c\u5bb9 \u8be5\u63d2\u4ef6\u4f7f\u7528 Cubism 2.1 \u548c Cubism 4\uff0c\u4ece\u800c\u652f\u6301\u6240\u6709\u7248\u672c\u7684 Live2D \u6a21\u578b","title":"Cubism"},{"location":"README.zh/#cubism-core","text":"\u5728\u4f7f\u7528\u8be5\u63d2\u4ef6\u4e4b\u524d\uff0c\u4f60\u9700\u8981\u52a0\u8f7d Cubism \u8fd0\u884c\u65f6\uff0c\u4e5f\u5c31\u662f Cubism Core Cubism 4 \u9700\u8981\u52a0\u8f7d live2dcubismcore.min.js \uff0c\u53ef\u4ee5\u4ece Cubism 4 SDK \u91cc\u89e3\u538b\u51fa\u6765\uff0c\u6216\u8005\u76f4\u63a5\u5f15\u7528 \u8fd9\u4e2a\u94fe\u63a5 \uff08 \u94fe\u63a5\u5076\u5c14\u4f1a\u6302\u6389\uff0c\u4e0d\u8981\u5728\u751f\u4ea7\u7248\u672c\u4e2d\u4f7f\u7528\uff01 \uff09 Cubism 2.1 \u9700\u8981\u52a0\u8f7d live2d.min.js \uff0c \u4ece 2019/9/4 \u8d77 \uff0c\u5b98\u65b9\u5df2\u7ecf\u4e0d\u518d\u63d0\u4f9b\u8be5\u7248\u672c SDK \u7684\u4e0b\u8f7d\uff0c\u4f46\u662f\u53ef\u4ee5\u4ece \u8fd9\u91cc \u627e\u5230\uff0c\u4ee5\u53ca\u4f60\u5927\u6982\u60f3\u8981\u7684 CDN \u94fe\u63a5","title":"Cubism Core"},{"location":"README.zh/#_5","text":"\u8be5\u63d2\u4ef6\u4e3a\u6bcf\u4e2a Cubism \u7248\u672c\u63d0\u4f9b\u4e86\u5355\u72ec\u7684\u6253\u5305\u6587\u4ef6\uff0c\u4ece\u800c\u5728\u4f60\u53ea\u60f3\u4f7f\u7528\u5176\u4e2d\u4e00\u4e2a\u7248\u672c\u7684\u65f6\u5019\u51cf\u5c11\u9700\u8981\u52a0\u8f7d\u6587\u4ef6\u7684\u5927\u5c0f\u3002 \u5177\u4f53\u6765\u8bf4\uff0c\u4e3a\u4e24\u79cd\u7248\u672c\u5206\u522b\u63d0\u4f9b\u4e86 cubism2.js \u548c cubism4.js \uff0c\u4ee5\u53ca\u4e00\u4e2a\u540c\u65f6\u5305\u542b\u4e86\u4e24\u79cd\u7248\u672c\u7684 index.js \u6ce8\u610f\uff0c\u5982\u679c\u4f60\u60f3\u540c\u65f6\u652f\u6301 Cubism 2.1 \u548c Cubism 4 \u7684\u8bdd\uff0c\u8bf7\u4f7f\u7528 index.js \uff0c \u800c\u4e0d\u8981\u540c\u65f6\u4f7f\u7528 cubism2.js \u548c cubism4.js \u4e3a\u4e86\u66f4\u660e\u786e\u4e00\u70b9\uff0c\u8fd9\u91cc\u5217\u51fa\u4f7f\u7528\u8fd9\u4e9b\u6587\u4ef6\u7684\u65b9\u6cd5\uff1a \u4f7f\u7528 cubism2.js + live2d.min.js \u4ee5\u652f\u6301 Cubism 2.1 \u6a21\u578b \u4f7f\u7528 cubism4.js + live2dcubismcore.min.js \u4ee5\u652f\u6301 Cubism 3 \u548c Cubism 4 \u6a21\u578b \u4f7f\u7528 index.js + live2d.min.js + live2dcubismcore.min.js \u4ee5\u652f\u6301\u6240\u6709\u7248\u672c\u7684\u6a21\u578b","title":"\u5355\u72ec\u7684\u6253\u5305\u6587\u4ef6"},{"location":"README.zh/#_6","text":"","title":"\u5b89\u88c5"},{"location":"README.zh/#npm","text":"npm install pixi-live2d-display import { Live2DModel } from 'pixi-live2d-display' ; // \u5982\u679c\u53ea\u9700\u8981 Cubism 2.1 import { Live2DModel } from 'pixi-live2d-display/lib/cubism2' ; // \u5982\u679c\u53ea\u9700\u8981 Cubism 4 import { Live2DModel } from 'pixi-live2d-display/lib/cubism4' ;","title":"\u901a\u8fc7 npm"},{"location":"README.zh/#cdn","text":"< script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/index.min.js\" ></ script > <!-- \u5982\u679c\u53ea\u9700\u8981 Cubism 2.1 --> < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/cubism2.min.js\" ></ script > <!-- \u5982\u679c\u53ea\u9700\u8981 Cubism 4 --> < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/cubism4.min.js\" ></ script > \u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u52a0\u8f7d\u7684\u8bdd\uff0c\u6240\u6709\u6210\u5458\u90fd\u4f1a\u88ab\u5bfc\u51fa\u5230 PIXI.live2d \u547d\u540d\u7a7a\u95f4\u4e0b\uff0c\u6bd4\u5982 PIXI.live2d.Live2DModel","title":"\u901a\u8fc7 CDN"},{"location":"README.zh/#_7","text":"","title":"\u4f7f\u7528"},{"location":"README.zh/#_8","text":"import * as PIXI from 'pixi.js' ; // \u5982\u679c\u5b58\u5728\u5168\u5c40\u7684 PIXI \u53d8\u91cf\uff0c\u8be5\u63d2\u4ef6\u4f1a\u81ea\u52a8\u5f15\u7528\u6240\u9700\u7684\u529f\u80fd\uff0c\u6bd4\u5982 window.PIXI.Ticker window . PIXI = PIXI ; // \u6240\u4ee5\uff0c\u8fd9\u91cc\u9700\u8981\u4f7f\u7528 require() \u6765\u5bfc\u5165\u6a21\u5757\u800c\u4e0d\u662f import \u8bed\u53e5\uff0c\u56e0\u4e3a\u540e\u8005\u4f1a\u5728\u7f16\u8bd1\u65f6\u88ab // \u63d0\u5347\uff08hoist\uff09\u5230\u4e0a\u9762\u8d4b\u503c\u8bed\u53e5\u7684\u524d\u9762 const { Live2DModel } = require ( 'pixi-live2d-display' ); async function main () { const app = new PIXI . Application ({ view : document . getElementById ( 'canvas' ), autoStart : true }); const model = await Live2DModel . from ( 'shizuku.model.json' ); app . stage . addChild ( model ); // \u53d8\u6362 model . x = 100 ; model . y = 100 ; model . rotation = Math . PI ; model . skew . x = Math . PI ; model . scale . set ( 2 , 2 ); model . anchor . set ( 0.5 , 0.5 ); // \u4ea4\u4e92 model . on ( 'hit' , hitAreas => { if ( hitAreas . includes ( 'body' )) { model . motion ( 'tap_body' ); } }); }","title":"\u57fa\u7840"},{"location":"README.zh/#_9","text":"Pixi \u63d0\u4f9b\u4e86\u5355\u72ec\u7684\u5305\u4ee5\u652f\u6301\u6309\u9700\u5bfc\u5165\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u60f3\u8981\u4f7f\u7528\u67d0\u4e9b\u529f\u80fd\uff0c\u5219\u9700\u8981\u624b\u52a8\u6ce8\u518c\u76f8\u5e94\u7684\u7ec4\u4ef6 import { Application } from '@pixi/app' ; import { Renderer } from '@pixi/core' ; import { Ticker , TickerPlugin } from '@pixi/ticker' ; import { InteractionManager } from '@pixi/interaction' ; import { Live2DModel } from 'pixi-live2d-display' ; // \u6ce8\u518c Ticker \u4ee5\u652f\u6301 Live2D \u6a21\u578b\u7684\u81ea\u52a8\u66f4\u65b0 Application . registerPlugin ( TickerPlugin ); Live2DModel . registerTicker ( Ticker ); // \u6ce8\u518c InteractionManager \u4ee5\u652f\u6301 Live2D \u6a21\u578b\u7684\u81ea\u52a8\u4ea4\u4e92 Renderer . registerPlugin ( 'interaction' , InteractionManager ); async function main () { const app = new Application (); const model = await Live2DModel . from ( 'shizuku.model.json' ); app . stage . addChild ( model ); } \u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u8bbf\u95ee Wiki \uff08\u6682\u65e0\u4e2d\u6587\u7ffb\u8bd1\uff09 \u793a\u4f8b\u7684 Live2D \u6a21\u578b Shizuku (Cubism 2.1) \u548c Haru (Cubism 4) \u9075\u5b88 Live2D \u7684 Free Material License","title":"\u5305\u5bfc\u5165"},{"location":"additional/","text":"These features are not strongly related to the subject of this project - \"displaying Live2D\", but can be useful sometimes. HitAreaFrames \u00b6 Displays a frame for model's each hit area. You can see this in the interaction demo . The HitAreaFrames must be used as a direct child of Live2DModel . const hitAreaFrames = new HitAreaFrames (); model . addChild ( hitAreaFrames ); Because this class involves the dependency of PIXI.Graphics , it's included in the browser build, but not in the module system build. In browser, you can directly use the PIXI.live2d.HitAreaFrames . In Node, you can import the source file: import { HitAreaFrames } from 'pixi-live2d-display/src/tools/HitAreaFrames' ; However it's a TypeScript file, so you'll need an appropriate loader, such as ts-loader when using webpack. And unfortunately, while importing this file works, the TypeScript compiler will report an error due to the path alias @ in this file. This can be fixed once webpack supports ES module output . For now, I'd suggest copying this file to your project and replacing @/Live2DModel with ../Live2DModel in the first line. Loading from uploaded files (experimental) \u00b6 You can create a model by an array of File objects, each of which has a webkitRelativePath property. document . getElementById ( \"filepicker\" ). addEventListener ( \"change\" , function ( event ) { const files = event . target . files ; if ( files . length ) { const model = await Live2DModel . from ( files ); } }); Files will be handled by the FileLoader . From given files, it looks for the model settings file by matching the model.json or model3.json extension, then creates a lookup table for the resource files defined in the settings, where the keys are the files' paths and the values are their object URLs. If there are more than one settings file, only the first one will be chosen by default, but you can specify it by attaching a ModelSettings to the file array. // files: // shizuku-normal.model.json // shizuku-special.model.json // shizuku.moc // texture_0.png // ... const files = getUploadedFiles (); // if you do this, the model will be created by \"shizuku-normal.model.json\" as it's the first matched settings file // const model = await Live2DModel.from(files); const settingsFile = files . find ( file => file . name === 'shizuku-special.model.json' ); // load JSON from the file const settingsJSON = await fetch ( URL . createObjectURL ( settingsFile )). then ( res => res . json ()); // don't forget to specify the url settingsJSON . url = settingsFile . webkitRelativePath ; files . settings = new Cubism2ModelSettings ( settingsJSON ); // now the model will be created by \"shizuku-special.model.json\" const model = await Live2DModel . from ( files ); // to be honest, I just found myself so dumb when writing this guide... // why didn't I just add an option to the `options` of Live2DModel.from()? If the given files include no settings file, an error will be thrown. Loading from a zip file (experimental) \u00b6 Zip files will be handled by the ZipLoader . It looks for the model settings file in the zip, extracts the resource files as File s, then simply passes them to the FileLoader . To avoid depending on a zipping library, ZipLoader has left several static methods unimplemented, therefore you need to implement them before loading zip files, otherwise a \"Not implemented\" error will be thrown . // the type `ZipReader` is an arbitrary object // accepts the zip's data and URL, returns a zip reader ZipLoader . zipReader ( data : Blob , url : string ) : Promise < ZipReader > // retrieves relative paths of all the files in this zip ZipLoader . getFilePaths ( reader : ZipReader ) : Promise < string [] > // extracts specific files in this zip as `File` objects ZipLoader . getFiles ( reader : ZipReader , paths : string []) : Promise < File [] > // reads a file in this zip as text ZipLoader . readText ( reader : ZipReader , path : string ) : Promise < string > // releases the zip reader, this is optional ZipLoader . releaseReader ( reader : ZipReader ) : void An example for implementing them with jszip can be found in the live2d-viewer-web project. Then, you can create model from a zip file. Live2DModel . from ( 'path/to/shizuku.zip' ); If the zip file's URL is not ended with .zip , you can prepend the URL with a fake protocol zip:// . Live2DModel . from ( 'zip://path/to/shizuku' ); Live2DModel . from ( 'zip://http://example.com/give-me-a-random-model' ); Additionally, you can even pass an uploaded zip file. < input type = \"file\" id = \"zippicker\" accept = \".zip\" > document . getElementById ( \"zippicker\" ). addEventListener ( \"change\" , async function ( event ) { const files = event . target . files ; if ( files . length ) { // the zip source is a one-length array containing a single zip file const zipSource = [ files [ 0 ]]; const model = await Live2DModel . from ( zipSource ); } }); In this way, you're also able to specify the target settings file with the same approach as above.","title":"Additional Features"},{"location":"additional/#hitareaframes","text":"Displays a frame for model's each hit area. You can see this in the interaction demo . The HitAreaFrames must be used as a direct child of Live2DModel . const hitAreaFrames = new HitAreaFrames (); model . addChild ( hitAreaFrames ); Because this class involves the dependency of PIXI.Graphics , it's included in the browser build, but not in the module system build. In browser, you can directly use the PIXI.live2d.HitAreaFrames . In Node, you can import the source file: import { HitAreaFrames } from 'pixi-live2d-display/src/tools/HitAreaFrames' ; However it's a TypeScript file, so you'll need an appropriate loader, such as ts-loader when using webpack. And unfortunately, while importing this file works, the TypeScript compiler will report an error due to the path alias @ in this file. This can be fixed once webpack supports ES module output . For now, I'd suggest copying this file to your project and replacing @/Live2DModel with ../Live2DModel in the first line.","title":"HitAreaFrames"},{"location":"additional/#loading-from-uploaded-files-experimental","text":"You can create a model by an array of File objects, each of which has a webkitRelativePath property. document . getElementById ( \"filepicker\" ). addEventListener ( \"change\" , function ( event ) { const files = event . target . files ; if ( files . length ) { const model = await Live2DModel . from ( files ); } }); Files will be handled by the FileLoader . From given files, it looks for the model settings file by matching the model.json or model3.json extension, then creates a lookup table for the resource files defined in the settings, where the keys are the files' paths and the values are their object URLs. If there are more than one settings file, only the first one will be chosen by default, but you can specify it by attaching a ModelSettings to the file array. // files: // shizuku-normal.model.json // shizuku-special.model.json // shizuku.moc // texture_0.png // ... const files = getUploadedFiles (); // if you do this, the model will be created by \"shizuku-normal.model.json\" as it's the first matched settings file // const model = await Live2DModel.from(files); const settingsFile = files . find ( file => file . name === 'shizuku-special.model.json' ); // load JSON from the file const settingsJSON = await fetch ( URL . createObjectURL ( settingsFile )). then ( res => res . json ()); // don't forget to specify the url settingsJSON . url = settingsFile . webkitRelativePath ; files . settings = new Cubism2ModelSettings ( settingsJSON ); // now the model will be created by \"shizuku-special.model.json\" const model = await Live2DModel . from ( files ); // to be honest, I just found myself so dumb when writing this guide... // why didn't I just add an option to the `options` of Live2DModel.from()? If the given files include no settings file, an error will be thrown.","title":"Loading from uploaded files (experimental)"},{"location":"additional/#loading-from-a-zip-file-experimental","text":"Zip files will be handled by the ZipLoader . It looks for the model settings file in the zip, extracts the resource files as File s, then simply passes them to the FileLoader . To avoid depending on a zipping library, ZipLoader has left several static methods unimplemented, therefore you need to implement them before loading zip files, otherwise a \"Not implemented\" error will be thrown . // the type `ZipReader` is an arbitrary object // accepts the zip's data and URL, returns a zip reader ZipLoader . zipReader ( data : Blob , url : string ) : Promise < ZipReader > // retrieves relative paths of all the files in this zip ZipLoader . getFilePaths ( reader : ZipReader ) : Promise < string [] > // extracts specific files in this zip as `File` objects ZipLoader . getFiles ( reader : ZipReader , paths : string []) : Promise < File [] > // reads a file in this zip as text ZipLoader . readText ( reader : ZipReader , path : string ) : Promise < string > // releases the zip reader, this is optional ZipLoader . releaseReader ( reader : ZipReader ) : void An example for implementing them with jszip can be found in the live2d-viewer-web project. Then, you can create model from a zip file. Live2DModel . from ( 'path/to/shizuku.zip' ); If the zip file's URL is not ended with .zip , you can prepend the URL with a fake protocol zip:// . Live2DModel . from ( 'zip://path/to/shizuku' ); Live2DModel . from ( 'zip://http://example.com/give-me-a-random-model' ); Additionally, you can even pass an uploaded zip file. < input type = \"file\" id = \"zippicker\" accept = \".zip\" > document . getElementById ( \"zippicker\" ). addEventListener ( \"change\" , async function ( event ) { const files = event . target . files ; if ( files . length ) { // the zip source is a one-length array containing a single zip file const zipSource = [ files [ 0 ]]; const model = await Live2DModel . from ( zipSource ); } }); In this way, you're also able to specify the target settings file with the same approach as above.","title":"Loading from a zip file (experimental)"},{"location":"configs/","text":"You can apply global configs for all models. import { config } from 'pixi-live2d-display' ; // log level config . logLevel = config . LOG_LEVEL_WARNING ; // LOG_LEVEL_VERBOSE, LOG_LEVEL_ERROR, LOG_LEVEL_NONE // play sound for motions config . sound = true ; // defer the playbacks of a motion and its sound until both are loaded config . motionSync = true ; // the default fade-in and fade-out durations, applied when a motion/expression doesn't have these values specified config . motionFadingDuration = 500 ; config . idleMotionFadingDuration = 500 ; config . expressionFadingDuration = 500 ; // support for 4x4 mask division in Cubism 4, which is unofficial and experimental config . cubism4 . supportMoreMaskDivisions = true ;","title":"Configs"},{"location":"development/","text":"Setup \u00b6 Run the setup script to set up the environment. yarn setup Testing \u00b6 Run test for a headless test, or test:debug for a headful test. yarn test yarn test:debug Note there's a browser test suite that requires a production bundle, so you'll need to build the library before running tests. yarn build You don't have to build it every time, just do it when you think necessary. Playground \u00b6 There's a playground with hot reload enabled, it's useful for debugging. yarn playground Then make changes to the tests/playground/index.ts and check the result. Modifications of this file should not be committed to git. You can run this command to tell git not to track this file: git update-index --skip-worktree test/playground/index.ts","title":"Development"},{"location":"development/#setup","text":"Run the setup script to set up the environment. yarn setup","title":"Setup"},{"location":"development/#testing","text":"Run test for a headless test, or test:debug for a headful test. yarn test yarn test:debug Note there's a browser test suite that requires a production bundle, so you'll need to build the library before running tests. yarn build You don't have to build it every time, just do it when you think necessary.","title":"Testing"},{"location":"development/#playground","text":"There's a playground with hot reload enabled, it's useful for debugging. yarn playground Then make changes to the tests/playground/index.ts and check the result. Modifications of this file should not be committed to git. You can run this command to tell git not to track this file: git update-index --skip-worktree test/playground/index.ts","title":"Playground"},{"location":"graphs/","text":".md-sidebar--secondary { display: none !important; } .md-content code { font-size: .72em !important; } Main Components \u00b6 Live2DModel | _________________________________________ InternalModel ______________________________________________ / | | | \\ Abstraction: (core model) ModelSettings MotionManager ExpressionManager FocusController | | | | Cubism 2: |-Live2DModelWebGL |-Cubism2ModelSettings |-Cubism2MotionManager |-Cubism2ExpressionManager | | | | Cubism 4: |-CubismModel |-Cubism4ModelSettings |-Cubism4MotionManager |-Cubism4ExpressionManager Model Creation Procedure \u00b6 Live2DModel ^ | Live2DModel.fromSync(source) \"load\" ______________|________________ ______|______ / | \\ / \\ v v v | \"ready\" (source) (source) (source) ________________ | ______________|__________________________ | | | / _____|_____ | \\ v v v | / \\ | | artifacts: URL settingsJSON ModelSettings Pose Physics Texture[] InternalModel | ^ \\ ^ \\ ^ ^ ^ ^ | / \\ | \\ | / | | events: | \"settingsJSONLoaded\" \\ \"settingsLoaded\" \\ \"poseLoaded\" \"physicsLoaded\" \"textureLoaded\" \"modelLoaded\" v / v | v | / | | middlewares: urlToJSON() ~~> jsonToSettings() ~~> setupOptionals() ~~> setupLive2DModel() ~~> createInternalModel()","title":"Graphs"},{"location":"graphs/#main-components","text":"Live2DModel | _________________________________________ InternalModel ______________________________________________ / | | | \\ Abstraction: (core model) ModelSettings MotionManager ExpressionManager FocusController | | | | Cubism 2: |-Live2DModelWebGL |-Cubism2ModelSettings |-Cubism2MotionManager |-Cubism2ExpressionManager | | | | Cubism 4: |-CubismModel |-Cubism4ModelSettings |-Cubism4MotionManager |-Cubism4ExpressionManager","title":"Main Components"},{"location":"graphs/#model-creation-procedure","text":"Live2DModel ^ | Live2DModel.fromSync(source) \"load\" ______________|________________ ______|______ / | \\ / \\ v v v | \"ready\" (source) (source) (source) ________________ | ______________|__________________________ | | | / _____|_____ | \\ v v v | / \\ | | artifacts: URL settingsJSON ModelSettings Pose Physics Texture[] InternalModel | ^ \\ ^ \\ ^ ^ ^ ^ | / \\ | \\ | / | | events: | \"settingsJSONLoaded\" \\ \"settingsLoaded\" \\ \"poseLoaded\" \"physicsLoaded\" \"textureLoaded\" \"modelLoaded\" v / v | v | / | | middlewares: urlToJSON() ~~> jsonToSettings() ~~> setupOptionals() ~~> setupLive2DModel() ~~> createInternalModel()","title":"Model Creation Procedure"},{"location":"interactions/","text":"There are two basic interactions on a Live2D model: Focusing: the Live2D character will look at the cursor. Tapping: handles the pointertap event, then emits a hit event when any of the defined hit areas is tapped on. The hit event comes with an array of the names of hit hit areas. model . on ( 'hit' , hitAreaNames => { if ( hitAreaNames . includes ( 'body' )) { // the body is hit } }); See Collision Detection for more information about the hit-testing. Interacting Automatically \u00b6 When a full build of PixiJS is imported, the above interactions will be automatically set up. import * as PIXI from 'pixi.js' ; Otherwise, you need to manually register Pixi's interaction plugin. import { Renderer } from '@pixi/core' ; import { InteractionManager } from '@pixi/interaction' ; Renderer . registerPlugin ( 'interaction' , InteractionManager ); Interacting Manually \u00b6 If you don't want the default behaviour, you can disable the autoInteract option, then manually call the interaction methods. const model = await Live2DModel . from ( 'shizuku.model.json' , { autoInteract : false }); canvasElement . addEventListener ( 'pointermove' , event => model . focus ( event . clientX , event . clientY )); canvasElement . addEventListener ( 'pointerdown' , event => model . tap ( event . clientX , event . clientY ));","title":"Interactions"},{"location":"interactions/#interacting-automatically","text":"When a full build of PixiJS is imported, the above interactions will be automatically set up. import * as PIXI from 'pixi.js' ; Otherwise, you need to manually register Pixi's interaction plugin. import { Renderer } from '@pixi/core' ; import { InteractionManager } from '@pixi/interaction' ; Renderer . registerPlugin ( 'interaction' , InteractionManager );","title":"Interacting Automatically"},{"location":"interactions/#interacting-manually","text":"If you don't want the default behaviour, you can disable the autoInteract option, then manually call the interaction methods. const model = await Live2DModel . from ( 'shizuku.model.json' , { autoInteract : false }); canvasElement . addEventListener ( 'pointermove' , event => model . focus ( event . clientX , event . clientY )); canvasElement . addEventListener ( 'pointerdown' , event => model . tap ( event . clientX , event . clientY ));","title":"Interacting Manually"},{"location":"models/","text":"Main Components \u00b6 See Graphs . Creating a Model \u00b6 Models are created by a static method: Live2DModel.from(source, options) . Source \u00b6 The source can be one of these three types: A URL of the model settings file, which typically ends with .model.json (Cubism 2) or .model3.json (Cubism 3 and 4). const model = await Live2DModel . from ( 'path/to/shizuku.model.json' ); A JSON object of the model settings. However, you'll still need to specify the URL by assigning it to the url property of the JSON object, this approach is the same for all Cubism versions. const url = 'path/to/shizuku.model.json' const json = await loadJSON ( url ); json . url = url ; const model = await Live2DModel . from ( json ); An instance of ModelSettings . Specifically, either Cubism2ModelSettings or Cubism4ModelSettings . const url = 'path/to/shizuku.model.json' const json = await loadJSON ( url ); json . url = url ; const settings = new Cubism2ModelSettings ( json ); const model = await Live2DModel . from ( settings ); !!! note You've probably noticed that the URL is always required, that's because a URL is essential to resolve the resource files of a model. For example, in a model with the URL foo/bar.model.json , the texture image textures/01.png will be resolved to foo/textures/01.png . Options \u00b6 The options is a combination of the options for multiple components, check the Live2DFactoryOptions . Synchronous Creation \u00b6 In case you want to participate in the creation, there's a synchronous creation method: Live2DModel.fromSync(source, options) . This method immediately returns a Live2DModel instance, whose resources have not been loaded. That means you can't manipulate or render this model - until the load event has been emitted. // no `await` here as it's not a Promise const model = Live2DModel . fromSync ( 'shizuku.model.json' , { onError : console . warn }); // these will cause errors! // app.stage.addChild(model); // model.motion('tap_body'); model . once ( 'load' , () => { // now it's safe app . stage . addChild ( model ); model . motion ( 'tap_body' ); }); With this method, you're able to do extra works when certain resources have been loaded. const model = Live2DModel . fromSync ( 'shizuku.model.json' ); model . once ( 'settingsJSONLoaded' , json => { // e.g. customize the layout before they are applied to the model Object . assign ( json , { layout : { width : 2 , height : 2 } }); }); model . once ( 'settingsLoaded' , settings => { // e.g. set another URL to the model settings . url = 'path/to/model' ; }); When all the essential resources have been loaded, a ready event is emitted. If you want the model to show up as soon as possible, you can render the model safely at this moment. After that, when all the resources - including the optional resources - have been loaded, the load event is emitted. The behaviors of ready and load events are pretty much like jQuery's $(document).ready() and the window.onload() . const model = Live2DModel . fromSync ( 'shizuku.model.json' ); model . once ( 'ready' , () => { // it's also safe to do these now, though not recommended because // a model will typically look weird when rendered without optional resources app . stage . addChild ( model ); model . motion ( 'tap_body' ); }); The creation procedure along with all the emitted events can be found in the Graphs . Updating a Model \u00b6 To make a Live2D model \"live\", it needs to be updated with the delta time, which is the time elapsed from last frame to this frame, in milliseconds. Automatically \u00b6 When a full build of PixiJS is imported and assigned to window.PIXI , each model will be automatically updated using window.PIXI.Ticker.shared . import * as PIXI from 'pixi.js' ; window . PIXI = PIXI ; Otherwise, you can manually register the Ticker to achieve automatic updating. import { Application } from '@pixi/app' ; import { Ticker , TickerPlugin } from '@pixi/ticker' ; Application . registerPlugin ( TickerPlugin ); Live2DModel . registerTicker ( Ticker ); Manually \u00b6 To manually update the model, you need to first disable the autoUpdate option, and then call model.update() every tick. import { Ticker } from '@pixi/ticker' ; const model = await Live2DModel . from ( 'shizuku.model.json' , { autoUpdate : false }); const ticker = new Ticker (); ticker . add (() => model . update ( ticker . elapsedMS )); When you're using the requestAnimationFrame() instead: const model = await Live2DModel . from ( 'shizuku.model.json' , { autoUpdate : false }); let then = performance . now (); function tick ( now ) { model . update ( now - then ); then = now ; requestAnimationFrame ( tick ); } requestAnimationFrame ( tick );","title":"Models"},{"location":"models/#main-components","text":"See Graphs .","title":"Main Components"},{"location":"models/#creating-a-model","text":"Models are created by a static method: Live2DModel.from(source, options) .","title":"Creating a Model"},{"location":"models/#source","text":"The source can be one of these three types: A URL of the model settings file, which typically ends with .model.json (Cubism 2) or .model3.json (Cubism 3 and 4). const model = await Live2DModel . from ( 'path/to/shizuku.model.json' ); A JSON object of the model settings. However, you'll still need to specify the URL by assigning it to the url property of the JSON object, this approach is the same for all Cubism versions. const url = 'path/to/shizuku.model.json' const json = await loadJSON ( url ); json . url = url ; const model = await Live2DModel . from ( json ); An instance of ModelSettings . Specifically, either Cubism2ModelSettings or Cubism4ModelSettings . const url = 'path/to/shizuku.model.json' const json = await loadJSON ( url ); json . url = url ; const settings = new Cubism2ModelSettings ( json ); const model = await Live2DModel . from ( settings ); !!! note You've probably noticed that the URL is always required, that's because a URL is essential to resolve the resource files of a model. For example, in a model with the URL foo/bar.model.json , the texture image textures/01.png will be resolved to foo/textures/01.png .","title":"Source"},{"location":"models/#options","text":"The options is a combination of the options for multiple components, check the Live2DFactoryOptions .","title":"Options"},{"location":"models/#synchronous-creation","text":"In case you want to participate in the creation, there's a synchronous creation method: Live2DModel.fromSync(source, options) . This method immediately returns a Live2DModel instance, whose resources have not been loaded. That means you can't manipulate or render this model - until the load event has been emitted. // no `await` here as it's not a Promise const model = Live2DModel . fromSync ( 'shizuku.model.json' , { onError : console . warn }); // these will cause errors! // app.stage.addChild(model); // model.motion('tap_body'); model . once ( 'load' , () => { // now it's safe app . stage . addChild ( model ); model . motion ( 'tap_body' ); }); With this method, you're able to do extra works when certain resources have been loaded. const model = Live2DModel . fromSync ( 'shizuku.model.json' ); model . once ( 'settingsJSONLoaded' , json => { // e.g. customize the layout before they are applied to the model Object . assign ( json , { layout : { width : 2 , height : 2 } }); }); model . once ( 'settingsLoaded' , settings => { // e.g. set another URL to the model settings . url = 'path/to/model' ; }); When all the essential resources have been loaded, a ready event is emitted. If you want the model to show up as soon as possible, you can render the model safely at this moment. After that, when all the resources - including the optional resources - have been loaded, the load event is emitted. The behaviors of ready and load events are pretty much like jQuery's $(document).ready() and the window.onload() . const model = Live2DModel . fromSync ( 'shizuku.model.json' ); model . once ( 'ready' , () => { // it's also safe to do these now, though not recommended because // a model will typically look weird when rendered without optional resources app . stage . addChild ( model ); model . motion ( 'tap_body' ); }); The creation procedure along with all the emitted events can be found in the Graphs .","title":"Synchronous Creation"},{"location":"models/#updating-a-model","text":"To make a Live2D model \"live\", it needs to be updated with the delta time, which is the time elapsed from last frame to this frame, in milliseconds.","title":"Updating a Model"},{"location":"models/#automatically","text":"When a full build of PixiJS is imported and assigned to window.PIXI , each model will be automatically updated using window.PIXI.Ticker.shared . import * as PIXI from 'pixi.js' ; window . PIXI = PIXI ; Otherwise, you can manually register the Ticker to achieve automatic updating. import { Application } from '@pixi/app' ; import { Ticker , TickerPlugin } from '@pixi/ticker' ; Application . registerPlugin ( TickerPlugin ); Live2DModel . registerTicker ( Ticker );","title":"Automatically"},{"location":"models/#manually","text":"To manually update the model, you need to first disable the autoUpdate option, and then call model.update() every tick. import { Ticker } from '@pixi/ticker' ; const model = await Live2DModel . from ( 'shizuku.model.json' , { autoUpdate : false }); const ticker = new Ticker (); ticker . add (() => model . update ( ticker . elapsedMS )); When you're using the requestAnimationFrame() instead: const model = await Live2DModel . from ( 'shizuku.model.json' , { autoUpdate : false }); let then = performance . now (); function tick ( now ) { model . update ( now - then ); then = now ; requestAnimationFrame ( tick ); } requestAnimationFrame ( tick );","title":"Manually"},{"location":"motions_expressions/","text":"Motions are managed by the MotionManager of each model. Idle Motions \u00b6 When the model is not playing any motion, it's considered idle, and then its motion manager will randomly start an idle motion as the idle priority. Idle motions refer to the ones defined in a particular motion group: \"idle\" on Cubism 2, and \"Idle\" on Cubism 4. But you can specify another group according to the model's definition. model . internalModel . motionManager . groups . idle = 'main_idle' ; You can also specify it just when creating the model so this group can be correctly preloaded. const model = await Live2DModel . from ( 'shizuku.model.json' , { idleMotionGroup : 'main_idle' }); Preloading \u00b6 Motions can be preloaded to provide a seamless experience for users, but that may result in too many XHR requests that block the network. By default, only the idle motions will be preloaded. You can change this by setting the motionPreload option. import { MotionPreloadStrategy } from 'pixi-live2d-display' ; // MotionPreloadStrategy.ALL // MotionPreloadStrategy.IDLE // MotionPreloadStrategy.NONE const model = await Live2DModel . from ( 'shizuku.model.json' , { motionPreload : MotionPreloadStrategy . NONE }); Starting Motions \u00b6 // start the first motion in the \"tap_body\" group model . motion ( 'tap_body' , 0 ); // when the index is omitted, it starts a random motion in given group model . motion ( 'tap_body' ); // the above calls are shorthands of these methods model . internalModel . motionManager . startMotion ( 'tap_body' , 0 ); model . internalModel . motionManager . startRandomMotion ( 'tap_body' ); Priorities \u00b6 A motion will be started as one of these priorities: IDLE , NORMAL and FORCE . IDLE Low priority. A Live2D model will typically have a set of idle motions, they will be automatically played when there's no other motion playing. NORMAL Medium priority. This is the default value if you don't provide one. FORCE High priority. This makes sure the motion will always be played regardless of the current priority, except that it meets a race condition where a subsequent motion with the same priority is loaded before this motion. There's also a NONE priority which cannot be assigned to a motion, it's used to state that this model is currently not playing any motion. import { MotionPriority } from 'pixi-live2d-display' ; model . motion ( 'tap_body' , 0 , MotionPriority . NORMAL ); // a random motion as normal priority model . motion ( 'tap_body' , undefined , MotionPriority . NORMAL ); When a motion has been requested, and been approved to play, but meanwhile there's already a playing motion, it will not immediately take the place of the current motion, instead it reserves the place and starts to load. The current motion will keep playing until the reserved motion has finished loading. That said, the actual rules are more complicated, see the State-transition Table section for all the cases. Sounds \u00b6 If a sound file is specified within a motion definition, it'll be played together with this motion. During the playback, you can take control of all the created <audio> elements in SoundManager , like setting a global volume. import { SoundManager } from 'pixi-live2d-display' ; SoundManager . volume = 0.5 ; To handle the audios separately, you can listen to the motionStart event. model . internalModel . motionManager . on ( 'motionStart' , ( group , index , audio ) => { if ( audio ) { // assume you've implemented a feature to show subtitles showSubtitle ( group , index ); audio . addEventListener ( 'ended' , () => dismissSubtitle ()); } }); Motion Sync \u00b6 There are two parallel tasks while attempting to start a motion with sound: Load the motion, then play it Load the sound, then play it Typically, the playbacks of motion and its sound are supposed to start at the same time, that's what motion sync does: it defers the playbacks until the motion and sound have both been loaded. Load the motion and sound, then play both This feature can be toggled via global config , by default it's enabled. State-transition Table \u00b6 This table specifies which motion will finally be played when attempting to start a motion in a particular situation, assuming the loading will never fail and will be finished in a relatively short time. When: Start motion C as: NONE IDLE NORMAL FORCE Playing none Reserved none none C C C Playing A as IDLE Reserved none A A C C Playing A as NORMAL Reserved none A A A C Playing A as FORCE Reserved none A A A C Playing A as IDLE Reserved B as NORMAL B B B C Playing A as NORMAL Reserved B as FORCE B B B C Playing A as FORCE Reserved B as FORCE B B B C Playing none Reserved B as IDLE B B C C Playing none Reserved B as FORCE B B B C Playing none Reserved B as FORCE B B B C Expressions \u00b6 Expressions are managed by ExpressionManager in MotionManager . If the model has no expression defined in its settings, the ExpressionManager will not be created. // apply the first expression model . expression ( 0 ); // apply the expression named \"smile\" model . expression ( 'smile' ); // when the argument is omitted, it applies a random expression model . expression (); // the above calls are shorthands of these methods model . internalModel . motionManager . expressionManager . setExpression ( 0 ); model . internalModel . motionManager . expressionManager . setExpression ( 'smile' ); model . internalModel . motionManager . expressionManager . setRandomExpression ();","title":"Motions and Expressions"},{"location":"motions_expressions/#idle-motions","text":"When the model is not playing any motion, it's considered idle, and then its motion manager will randomly start an idle motion as the idle priority. Idle motions refer to the ones defined in a particular motion group: \"idle\" on Cubism 2, and \"Idle\" on Cubism 4. But you can specify another group according to the model's definition. model . internalModel . motionManager . groups . idle = 'main_idle' ; You can also specify it just when creating the model so this group can be correctly preloaded. const model = await Live2DModel . from ( 'shizuku.model.json' , { idleMotionGroup : 'main_idle' });","title":"Idle Motions"},{"location":"motions_expressions/#preloading","text":"Motions can be preloaded to provide a seamless experience for users, but that may result in too many XHR requests that block the network. By default, only the idle motions will be preloaded. You can change this by setting the motionPreload option. import { MotionPreloadStrategy } from 'pixi-live2d-display' ; // MotionPreloadStrategy.ALL // MotionPreloadStrategy.IDLE // MotionPreloadStrategy.NONE const model = await Live2DModel . from ( 'shizuku.model.json' , { motionPreload : MotionPreloadStrategy . NONE });","title":"Preloading"},{"location":"motions_expressions/#starting-motions","text":"// start the first motion in the \"tap_body\" group model . motion ( 'tap_body' , 0 ); // when the index is omitted, it starts a random motion in given group model . motion ( 'tap_body' ); // the above calls are shorthands of these methods model . internalModel . motionManager . startMotion ( 'tap_body' , 0 ); model . internalModel . motionManager . startRandomMotion ( 'tap_body' );","title":"Starting Motions"},{"location":"motions_expressions/#priorities","text":"A motion will be started as one of these priorities: IDLE , NORMAL and FORCE . IDLE Low priority. A Live2D model will typically have a set of idle motions, they will be automatically played when there's no other motion playing. NORMAL Medium priority. This is the default value if you don't provide one. FORCE High priority. This makes sure the motion will always be played regardless of the current priority, except that it meets a race condition where a subsequent motion with the same priority is loaded before this motion. There's also a NONE priority which cannot be assigned to a motion, it's used to state that this model is currently not playing any motion. import { MotionPriority } from 'pixi-live2d-display' ; model . motion ( 'tap_body' , 0 , MotionPriority . NORMAL ); // a random motion as normal priority model . motion ( 'tap_body' , undefined , MotionPriority . NORMAL ); When a motion has been requested, and been approved to play, but meanwhile there's already a playing motion, it will not immediately take the place of the current motion, instead it reserves the place and starts to load. The current motion will keep playing until the reserved motion has finished loading. That said, the actual rules are more complicated, see the State-transition Table section for all the cases.","title":"Priorities"},{"location":"motions_expressions/#sounds","text":"If a sound file is specified within a motion definition, it'll be played together with this motion. During the playback, you can take control of all the created <audio> elements in SoundManager , like setting a global volume. import { SoundManager } from 'pixi-live2d-display' ; SoundManager . volume = 0.5 ; To handle the audios separately, you can listen to the motionStart event. model . internalModel . motionManager . on ( 'motionStart' , ( group , index , audio ) => { if ( audio ) { // assume you've implemented a feature to show subtitles showSubtitle ( group , index ); audio . addEventListener ( 'ended' , () => dismissSubtitle ()); } });","title":"Sounds"},{"location":"motions_expressions/#motion-sync","text":"There are two parallel tasks while attempting to start a motion with sound: Load the motion, then play it Load the sound, then play it Typically, the playbacks of motion and its sound are supposed to start at the same time, that's what motion sync does: it defers the playbacks until the motion and sound have both been loaded. Load the motion and sound, then play both This feature can be toggled via global config , by default it's enabled.","title":"Motion Sync"},{"location":"motions_expressions/#state-transition-table","text":"This table specifies which motion will finally be played when attempting to start a motion in a particular situation, assuming the loading will never fail and will be finished in a relatively short time. When: Start motion C as: NONE IDLE NORMAL FORCE Playing none Reserved none none C C C Playing A as IDLE Reserved none A A C C Playing A as NORMAL Reserved none A A A C Playing A as FORCE Reserved none A A A C Playing A as IDLE Reserved B as NORMAL B B B C Playing A as NORMAL Reserved B as FORCE B B B C Playing A as FORCE Reserved B as FORCE B B B C Playing none Reserved B as IDLE B B C C Playing none Reserved B as FORCE B B B C Playing none Reserved B as FORCE B B B C","title":"State-transition Table"},{"location":"motions_expressions/#expressions","text":"Expressions are managed by ExpressionManager in MotionManager . If the model has no expression defined in its settings, the ExpressionManager will not be created. // apply the first expression model . expression ( 0 ); // apply the expression named \"smile\" model . expression ( 'smile' ); // when the argument is omitted, it applies a random expression model . expression (); // the above calls are shorthands of these methods model . internalModel . motionManager . expressionManager . setExpression ( 0 ); model . internalModel . motionManager . expressionManager . setExpression ( 'smile' ); model . internalModel . motionManager . expressionManager . setRandomExpression ();","title":"Expressions"}]}