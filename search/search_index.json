{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pixi-live2d-display \u00b6 English | \u4e2d\u6587 This readme is for v0.4.0, if you're looking for v0.3.1, see this . Live2D integration for PixiJS v6. This project aims to be a universal Live2D framework on the web platform. While the official Live2D framework is just complex and problematic, this project has rewritten it to unify and simplify the APIs, which allows you to control the Live2D models on a high level without the need to learn how the internal system works. Features \u00b6 Supports all versions of Live2D models Supports PIXI.RenderTexture and PIXI.Filter Pixi-style transform APIs: position, scale, rotation, skew, anchor Automatic interactions: focusing, hit-testing Enhanced motion reserving logic compared to the official framework Loading from uploaded files / zip files (experimental) Fully typed - we all love types! Requirements \u00b6 PixiJS: >6 Browser: WebGL, ES6 Demos \u00b6 Basic demo Interaction demo Render texture & filter demo Live2D Viewer Online Documentations \u00b6 Documentation API Documentation Cubism \u00b6 Cubism is the name of Live2D SDK. There are so far three versions of it: Cubism 2.1, Cubism 3 and Cubism 4; where Cubism 4 is backward-compatible with Cubism 3 models. This plugin supports all variants of Live2D models by using Cubism 2.1 and Cubism 4. Cubism Core \u00b6 Before using the plugin, you'll need to include the Cubism runtime library, aka Cubism Core. For Cubism 4, you need live2dcubismcore.min.js that can be extracted from the Cubism 4 SDK , or be referred by a direct link ( however the direct link is quite unreliable, don't use it in production! ). For Cubism 2.1, you need live2d.min.js . It's no longer downloadable from the official site since 2019/9/4 , but can be found here , and with a CDN link that you'll probably need. Individual Bundles \u00b6 The plugin provides individual bundles for each Cubism version to reduce your app's size when you just want to use one of the versions. Specifically, there are cubism2.js and cubism4.js for respective runtime, along with an index.js that includes both of them. Note that if you want both the Cubism 2.1 and Cubism 4 support, use index.js , but not the combination of cubism2.js and cubism4.js . To make it clear, here's how you would use these files: Use cubism2.js + live2d.min.js to support Cubism 2.1 models Use cubism4.js + live2dcubismcore.min.js to support Cubism 3 and Cubism 4 models Use index.js + live2d.min.js + live2dcubismcore.min.js to support all versions of models Installation \u00b6 Via npm \u00b6 npm install pixi-live2d-display import { Live2DModel } from 'pixi-live2d-display' ; // if only Cubism 2.1 import { Live2DModel } from 'pixi-live2d-display/cubism2' ; // if only Cubism 4 import { Live2DModel } from 'pixi-live2d-display/cubism4' ; Via CDN \u00b6 < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/index.min.js\" ></ script > <!-- if only Cubism 2.1 --> < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/cubism2.min.js\" ></ script > <!-- if only Cubism 4 --> < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/cubism4.min.js\" ></ script > In this way, all the exported members are available under PIXI.live2d namespace, such as PIXI.live2d.Live2DModel . Basic usage \u00b6 import * as PIXI from 'pixi.js' ; import { Live2DModel } from 'pixi-live2d-display' ; // expose PIXI to window so that this plugin is able to // reference window.PIXI.Ticker to automatically update Live2D models window . PIXI = PIXI ; ( async function () { const app = new PIXI . Application ({ view : document . getElementById ( 'canvas' ), }); const model = await Live2DModel . from ( 'shizuku.model.json' ); app . stage . addChild ( model ); // transforms model . x = 100 ; model . y = 100 ; model . rotation = Math . PI ; model . skew . x = Math . PI ; model . scale . set ( 2 , 2 ); model . anchor . set ( 0.5 , 0.5 ); // interaction model . on ( 'hit' , ( hitAreas ) => { if ( hitAreas . includes ( 'body' )) { model . motion ( 'tap_body' ); } }); })(); Package importing \u00b6 When importing Pixi packages on-demand, you may need to manually register some plugins to enable optional features. import { Application } from '@pixi/app' ; import { Ticker , TickerPlugin } from '@pixi/ticker' ; import { InteractionManager } from '@pixi/interaction' ; import { Live2DModel } from 'pixi-live2d-display' ; // register Ticker for Live2DModel Live2DModel . registerTicker ( Ticker ); // register Ticker for Application Application . registerPlugin ( TickerPlugin ); // register InteractionManager to make Live2D models interactive Renderer . registerPlugin ( 'interaction' , InteractionManager ); ( async function () { const app = new Application ({ view : document . getElementById ( 'canvas' ), }); const model = await Live2DModel . from ( 'shizuku.model.json' ); app . stage . addChild ( model ); })(); The example Live2D models, Shizuku (Cubism 2.1) and Haru (Cubism 4), are redistributed under Live2D's Free Material License .","title":"Home"},{"location":"#pixi-live2d-display","text":"English | \u4e2d\u6587 This readme is for v0.4.0, if you're looking for v0.3.1, see this . Live2D integration for PixiJS v6. This project aims to be a universal Live2D framework on the web platform. While the official Live2D framework is just complex and problematic, this project has rewritten it to unify and simplify the APIs, which allows you to control the Live2D models on a high level without the need to learn how the internal system works.","title":"pixi-live2d-display"},{"location":"#features","text":"Supports all versions of Live2D models Supports PIXI.RenderTexture and PIXI.Filter Pixi-style transform APIs: position, scale, rotation, skew, anchor Automatic interactions: focusing, hit-testing Enhanced motion reserving logic compared to the official framework Loading from uploaded files / zip files (experimental) Fully typed - we all love types!","title":"Features"},{"location":"#requirements","text":"PixiJS: >6 Browser: WebGL, ES6","title":"Requirements"},{"location":"#demos","text":"Basic demo Interaction demo Render texture & filter demo Live2D Viewer Online","title":"Demos"},{"location":"#documentations","text":"Documentation API Documentation","title":"Documentations"},{"location":"#cubism","text":"Cubism is the name of Live2D SDK. There are so far three versions of it: Cubism 2.1, Cubism 3 and Cubism 4; where Cubism 4 is backward-compatible with Cubism 3 models. This plugin supports all variants of Live2D models by using Cubism 2.1 and Cubism 4.","title":"Cubism"},{"location":"#cubism-core","text":"Before using the plugin, you'll need to include the Cubism runtime library, aka Cubism Core. For Cubism 4, you need live2dcubismcore.min.js that can be extracted from the Cubism 4 SDK , or be referred by a direct link ( however the direct link is quite unreliable, don't use it in production! ). For Cubism 2.1, you need live2d.min.js . It's no longer downloadable from the official site since 2019/9/4 , but can be found here , and with a CDN link that you'll probably need.","title":"Cubism Core"},{"location":"#individual-bundles","text":"The plugin provides individual bundles for each Cubism version to reduce your app's size when you just want to use one of the versions. Specifically, there are cubism2.js and cubism4.js for respective runtime, along with an index.js that includes both of them. Note that if you want both the Cubism 2.1 and Cubism 4 support, use index.js , but not the combination of cubism2.js and cubism4.js . To make it clear, here's how you would use these files: Use cubism2.js + live2d.min.js to support Cubism 2.1 models Use cubism4.js + live2dcubismcore.min.js to support Cubism 3 and Cubism 4 models Use index.js + live2d.min.js + live2dcubismcore.min.js to support all versions of models","title":"Individual Bundles"},{"location":"#installation","text":"","title":"Installation"},{"location":"#via-npm","text":"npm install pixi-live2d-display import { Live2DModel } from 'pixi-live2d-display' ; // if only Cubism 2.1 import { Live2DModel } from 'pixi-live2d-display/cubism2' ; // if only Cubism 4 import { Live2DModel } from 'pixi-live2d-display/cubism4' ;","title":"Via npm"},{"location":"#via-cdn","text":"< script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/index.min.js\" ></ script > <!-- if only Cubism 2.1 --> < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/cubism2.min.js\" ></ script > <!-- if only Cubism 4 --> < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/cubism4.min.js\" ></ script > In this way, all the exported members are available under PIXI.live2d namespace, such as PIXI.live2d.Live2DModel .","title":"Via CDN"},{"location":"#basic-usage","text":"import * as PIXI from 'pixi.js' ; import { Live2DModel } from 'pixi-live2d-display' ; // expose PIXI to window so that this plugin is able to // reference window.PIXI.Ticker to automatically update Live2D models window . PIXI = PIXI ; ( async function () { const app = new PIXI . Application ({ view : document . getElementById ( 'canvas' ), }); const model = await Live2DModel . from ( 'shizuku.model.json' ); app . stage . addChild ( model ); // transforms model . x = 100 ; model . y = 100 ; model . rotation = Math . PI ; model . skew . x = Math . PI ; model . scale . set ( 2 , 2 ); model . anchor . set ( 0.5 , 0.5 ); // interaction model . on ( 'hit' , ( hitAreas ) => { if ( hitAreas . includes ( 'body' )) { model . motion ( 'tap_body' ); } }); })();","title":"Basic usage"},{"location":"#package-importing","text":"When importing Pixi packages on-demand, you may need to manually register some plugins to enable optional features. import { Application } from '@pixi/app' ; import { Ticker , TickerPlugin } from '@pixi/ticker' ; import { InteractionManager } from '@pixi/interaction' ; import { Live2DModel } from 'pixi-live2d-display' ; // register Ticker for Live2DModel Live2DModel . registerTicker ( Ticker ); // register Ticker for Application Application . registerPlugin ( TickerPlugin ); // register InteractionManager to make Live2D models interactive Renderer . registerPlugin ( 'interaction' , InteractionManager ); ( async function () { const app = new Application ({ view : document . getElementById ( 'canvas' ), }); const model = await Live2DModel . from ( 'shizuku.model.json' ); app . stage . addChild ( model ); })(); The example Live2D models, Shizuku (Cubism 2.1) and Haru (Cubism 4), are redistributed under Live2D's Free Material License .","title":"Package importing"},{"location":"additional/","text":"These features are not strongly related to this project's main goal - \"displaying Live2D\", but can be useful sometimes. HitAreaFrames \u00b6 Displays frames for model's hit areas. You can see this in the interaction demo . HitAreaFrames must be used as a direct child of Live2DModel . const hitAreaFrames = new HitAreaFrames (); model . addChild ( hitAreaFrames ); This class depends on @pixi/graphics and @pixi/text , therefore it's excluded from the main bundle to avoid involving unnecessary dependency. You can import it from the extra bundle. import { HitAreaFrames } from 'pixi-live2d-display/extra' ; For using CDNs, you can load it like this: < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/extra.min.js\" ></ script > Then, access it from PIXI.live2d.HitAreaFrames . Loading model from uploaded files (experimental) \u00b6 Live2DModel can be created from an array of File s. Each File must have a webkitRelativePath property that represents relative path of the file. You can get the File s from a directory picker: < input type = \"file\" id = \"filepicker\" webkitdirectory multiple /> document . getElementById ( \"filepicker\" ). addEventListener ( \"change\" , async ( event ) => { const files = event . target . files ; if ( files . length ) { const model = await Live2DModel . from ( files ); } }); How this works Source files are handled by an internal helper FileLoader . From given files, it looks for model settings file by matching .model.json or .model3.json extension, then creates a lookup table for resource files defined in the settings, where the keys are the file paths and the values are their object URLs . Then, it overrides the model.modelSettings.resolveURL() method so that the resource files can be resolved to corresponding File s using the lookup table. If given files include more than one settings file, only the first one will be chosen. To use another one, you need to manually create a ModelSettings , and attach it to the array: const files = [ // collected files: // shizuku-normal.model.json // shizuku-special.model.json // shizuku.moc // texture_0.png // ... ]; // if you do this, the model will be created by \"shizuku-normal.model.json\" as it's the first matched settings file // const model = await Live2DModel.from(files); const settingsFile = files . find ( file => file . name === 'shizuku-special.model.json' ); // read JSON from the file const settingsJSON = await fetch ( URL . createObjectURL ( settingsFile )). then ( res => res . json ()); // don't forget to specify url! settingsJSON . url = settingsFile . webkitRelativePath ; // attach the settings to the array files . settings = new Cubism2ModelSettings ( settingsJSON ); const model = await Live2DModel . from ( files ); // to be honest, I just found myself so dumb when writing this guide... // why didn't I just add an option to the `options` of Live2DModel.from()? If given files include no settings file, an error will be thrown. Loading model from a zip file (experimental) \u00b6 How this works Zip files are handled by an internal helper ZipLoader . It looks for the model settings file inside the zip, extracts referenced resource files as File s, then simply passes them to FileLoader . To avoid depending on a zipping library, ZipLoader has left several static methods unimplemented, therefore you need to implement them before loading zip files, otherwise a \"Not implemented\" error will be thrown . Typings: // this can be anything depending on the zipping library you're using type ZipReader = any ; // accepts the zip's data and URL, returns a zip reader ZipLoader . zipReader ( data : Blob , url : string ) : Promise < ZipReader > // retrieves relative paths of all the files in this zip ZipLoader . getFilePaths ( reader : ZipReader ) : Promise < string [] > // extracts specific files in this zip as Files ZipLoader . getFiles ( reader : ZipReader , paths : string []) : Promise < File [] > // reads a file in this zip as text ZipLoader . readText ( reader : ZipReader , path : string ) : Promise < string > // releases the zip reader, this is optional ZipLoader . releaseReader ( reader : ZipReader ) : void Info An implementation example using jszip can be found in the live2d-viewer-web project. Then, you can create model from a zip file using its URL. Live2DModel . from ( 'path/to/shizuku.zip' ); If the zip file's URL does not end with .zip , you can prepend it with a fake protocol zip:// to get it recognized. Live2DModel . from ( 'zip://path/to/shizuku' ); Live2DModel . from ( 'zip://http://example.com/give-me-a-random-model' ); Additionally, you can even pass an uploaded zip file. < input type = \"file\" id = \"zippicker\" accept = \".zip\" > document . getElementById ( \"zippicker\" ). addEventListener ( \"change\" , async function ( event ) { const files = event . target . files ; if ( files . length ) { const model = await Live2DModel . from ( files ); } }); In this way, you're also able to specify the target settings file with the same approach as above.","title":"Additional Features"},{"location":"additional/#hitareaframes","text":"Displays frames for model's hit areas. You can see this in the interaction demo . HitAreaFrames must be used as a direct child of Live2DModel . const hitAreaFrames = new HitAreaFrames (); model . addChild ( hitAreaFrames ); This class depends on @pixi/graphics and @pixi/text , therefore it's excluded from the main bundle to avoid involving unnecessary dependency. You can import it from the extra bundle. import { HitAreaFrames } from 'pixi-live2d-display/extra' ; For using CDNs, you can load it like this: < script src = \"https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/extra.min.js\" ></ script > Then, access it from PIXI.live2d.HitAreaFrames .","title":"HitAreaFrames"},{"location":"additional/#loading-model-from-uploaded-files-experimental","text":"Live2DModel can be created from an array of File s. Each File must have a webkitRelativePath property that represents relative path of the file. You can get the File s from a directory picker: < input type = \"file\" id = \"filepicker\" webkitdirectory multiple /> document . getElementById ( \"filepicker\" ). addEventListener ( \"change\" , async ( event ) => { const files = event . target . files ; if ( files . length ) { const model = await Live2DModel . from ( files ); } }); How this works Source files are handled by an internal helper FileLoader . From given files, it looks for model settings file by matching .model.json or .model3.json extension, then creates a lookup table for resource files defined in the settings, where the keys are the file paths and the values are their object URLs . Then, it overrides the model.modelSettings.resolveURL() method so that the resource files can be resolved to corresponding File s using the lookup table. If given files include more than one settings file, only the first one will be chosen. To use another one, you need to manually create a ModelSettings , and attach it to the array: const files = [ // collected files: // shizuku-normal.model.json // shizuku-special.model.json // shizuku.moc // texture_0.png // ... ]; // if you do this, the model will be created by \"shizuku-normal.model.json\" as it's the first matched settings file // const model = await Live2DModel.from(files); const settingsFile = files . find ( file => file . name === 'shizuku-special.model.json' ); // read JSON from the file const settingsJSON = await fetch ( URL . createObjectURL ( settingsFile )). then ( res => res . json ()); // don't forget to specify url! settingsJSON . url = settingsFile . webkitRelativePath ; // attach the settings to the array files . settings = new Cubism2ModelSettings ( settingsJSON ); const model = await Live2DModel . from ( files ); // to be honest, I just found myself so dumb when writing this guide... // why didn't I just add an option to the `options` of Live2DModel.from()? If given files include no settings file, an error will be thrown.","title":"Loading model from uploaded files (experimental)"},{"location":"additional/#loading-model-from-a-zip-file-experimental","text":"How this works Zip files are handled by an internal helper ZipLoader . It looks for the model settings file inside the zip, extracts referenced resource files as File s, then simply passes them to FileLoader . To avoid depending on a zipping library, ZipLoader has left several static methods unimplemented, therefore you need to implement them before loading zip files, otherwise a \"Not implemented\" error will be thrown . Typings: // this can be anything depending on the zipping library you're using type ZipReader = any ; // accepts the zip's data and URL, returns a zip reader ZipLoader . zipReader ( data : Blob , url : string ) : Promise < ZipReader > // retrieves relative paths of all the files in this zip ZipLoader . getFilePaths ( reader : ZipReader ) : Promise < string [] > // extracts specific files in this zip as Files ZipLoader . getFiles ( reader : ZipReader , paths : string []) : Promise < File [] > // reads a file in this zip as text ZipLoader . readText ( reader : ZipReader , path : string ) : Promise < string > // releases the zip reader, this is optional ZipLoader . releaseReader ( reader : ZipReader ) : void Info An implementation example using jszip can be found in the live2d-viewer-web project. Then, you can create model from a zip file using its URL. Live2DModel . from ( 'path/to/shizuku.zip' ); If the zip file's URL does not end with .zip , you can prepend it with a fake protocol zip:// to get it recognized. Live2DModel . from ( 'zip://path/to/shizuku' ); Live2DModel . from ( 'zip://http://example.com/give-me-a-random-model' ); Additionally, you can even pass an uploaded zip file. < input type = \"file\" id = \"zippicker\" accept = \".zip\" > document . getElementById ( \"zippicker\" ). addEventListener ( \"change\" , async function ( event ) { const files = event . target . files ; if ( files . length ) { const model = await Live2DModel . from ( files ); } }); In this way, you're also able to specify the target settings file with the same approach as above.","title":"Loading model from a zip file (experimental)"},{"location":"configs/","text":"Configs are applied to all models. import { config } from 'pixi-live2d-display' ; // log level config . logLevel = config . LOG_LEVEL_WARNING ; // LOG_LEVEL_VERBOSE, LOG_LEVEL_ERROR, LOG_LEVEL_NONE // play sound for motions config . sound = true ; // defer the playback of a motion and its sound until both are loaded config . motionSync = true ; // default fade-in/fade-out durations in milliseconds, will be applied to // motions/expressions that don't have these values specified config . motionFadingDuration = 500 ; config . idleMotionFadingDuration = 500 ; config . expressionFadingDuration = 500 ; // unofficial and experimental support for 4x4 mask division in Cubism 4 config . cubism4 . supportMoreMaskDivisions = true ;","title":"Configs"},{"location":"development/","text":"Setup \u00b6 yarn install # this sets up the environments yarn setup Testing \u00b6 There's a browser test suite that requires production bundle, so you'll need to build before running tests. You don't have to build it every time, just do it when you think necessary. yarn build Run test for a headless test, or test:debug for a headful test. yarn test yarn test:debug Playground \u00b6 There's a playground with hot reload enabled, useful for debugging. yarn playground Then make changes to playground/index.ts and check the result. Modifications of this file should not be committed to git. You can run this command to tell git not to track this file: git update-index --skip-worktree playground/index.ts","title":"Development"},{"location":"development/#setup","text":"yarn install # this sets up the environments yarn setup","title":"Setup"},{"location":"development/#testing","text":"There's a browser test suite that requires production bundle, so you'll need to build before running tests. You don't have to build it every time, just do it when you think necessary. yarn build Run test for a headless test, or test:debug for a headful test. yarn test yarn test:debug","title":"Testing"},{"location":"development/#playground","text":"There's a playground with hot reload enabled, useful for debugging. yarn playground Then make changes to playground/index.ts and check the result. Modifications of this file should not be committed to git. You can run this command to tell git not to track this file: git update-index --skip-worktree playground/index.ts","title":"Playground"},{"location":"graphs/","text":"Model Creation Procedure \u00b6 Live2DModel ^ | Live2DModel.fromSync(source) \"load\" ______________|________________ ______|______ / | \\ / \\ v v v | \"ready\" (source) (source) (source) ________________ | ______________|__________________________ | | | / _____|_____ | \\ v v v | / \\ | | artifacts: URL settingsJSON ModelSettings Pose Physics Texture[] InternalModel | ^ \\ ^ \\ ^ ^ ^ ^ | / \\ | \\ | / | | events: | \"settingsJSONLoaded\" \\ \"settingsLoaded\" \\ \"poseLoaded\" \"physicsLoaded\" \"textureLoaded\" \"modelLoaded\" v / v | v | / | | middlewares: urlToJSON() ~~> jsonToSettings() ~~> setupOptionals() ~~> setupLive2DModel() ~~> createInternalModel()","title":"Graphs"},{"location":"graphs/#model-creation-procedure","text":"Live2DModel ^ | Live2DModel.fromSync(source) \"load\" ______________|________________ ______|______ / | \\ / \\ v v v | \"ready\" (source) (source) (source) ________________ | ______________|__________________________ | | | / _____|_____ | \\ v v v | / \\ | | artifacts: URL settingsJSON ModelSettings Pose Physics Texture[] InternalModel | ^ \\ ^ \\ ^ ^ ^ ^ | / \\ | \\ | / | | events: | \"settingsJSONLoaded\" \\ \"settingsLoaded\" \\ \"poseLoaded\" \"physicsLoaded\" \"textureLoaded\" \"modelLoaded\" v / v | v | / | | middlewares: urlToJSON() ~~> jsonToSettings() ~~> setupOptionals() ~~> setupLive2DModel() ~~> createInternalModel()","title":"Model Creation Procedure"},{"location":"interactions/","text":"There are two basic interactions on Live2D models: Focusing: character will look at the mouse pointer. Tapping: handles pointertap event, then emits a hit event when any of the hit areas is tapped on. The hit event comes with an array of hit area names. model . on ( 'hit' , ( hitAreaNames ) => { if ( hitAreaNames . includes ( 'body' )) { // body is hit } }); Tip See Live2D's Collision Detection for more information about hit test. Interacting Automatically \u00b6 This is the default behavior. Model will use Pixi's InteractionManager to automatically interact. The easiest way is to import a full build of Pixi, so that InteractionManager is registered out of the box. import * as PIXI from 'pixi.js' ; Otherwise, you need to manually register it as plugin: import { Renderer } from '@pixi/core' ; import { InteractionManager } from '@pixi/interaction' ; Renderer . registerPlugin ( 'interaction' , InteractionManager ); Interacting Manually \u00b6 If you don't want the default behavior, you can turn off the autoInteract option when creating a model, then manually call the interaction methods. const model = await Live2DModel . from ( 'shizuku.model.json' , { autoInteract : false }); canvasElement . addEventListener ( 'pointermove' , ( event ) => model . focus ( event . clientX , event . clientY )); canvasElement . addEventListener ( 'pointerdown' , ( event ) => model . tap ( event . clientX , event . clientY ));","title":"Interactions"},{"location":"interactions/#interacting-automatically","text":"This is the default behavior. Model will use Pixi's InteractionManager to automatically interact. The easiest way is to import a full build of Pixi, so that InteractionManager is registered out of the box. import * as PIXI from 'pixi.js' ; Otherwise, you need to manually register it as plugin: import { Renderer } from '@pixi/core' ; import { InteractionManager } from '@pixi/interaction' ; Renderer . registerPlugin ( 'interaction' , InteractionManager );","title":"Interacting Automatically"},{"location":"interactions/#interacting-manually","text":"If you don't want the default behavior, you can turn off the autoInteract option when creating a model, then manually call the interaction methods. const model = await Live2DModel . from ( 'shizuku.model.json' , { autoInteract : false }); canvasElement . addEventListener ( 'pointermove' , ( event ) => model . focus ( event . clientX , event . clientY )); canvasElement . addEventListener ( 'pointerdown' , ( event ) => model . tap ( event . clientX , event . clientY ));","title":"Interacting Manually"},{"location":"models/","text":".cubism2 .nodeLabel, .cubism4 .nodeLabel { color: white !important; } .cubism2 > rect { fill: #2d8135 !important; } .cubism4 > rect { fill: #2849b1 !important; } Class diagram \u00b6 Tip Zoom in the webpage if diagram is too small. classDiagram direction LR class Live2DModel{ internalModel: InternalModel } class InternalModel{ <<abstract>> coreModel: unknown settings: ModelSettings motionManager: MotionManager focusController: FocusController } class ModelSettings{ <<abstract>> } class MotionManager{ <<abstract>> expressionManager: ExpressionManager } class ExpressionManager{ <<abstract>> } class FocusController class Live2DModelWebGL:::cubism2 class CubismModel:::cubism4 class Cubism2InternalModel:::cubism2{ coreModel: Live2DModelWebGL } class Cubism4InternalModel:::cubism4{ coreModel: CubismModel } class Cubism2ModelSettings:::cubism2 class Cubism4ModelSettings:::cubism4 class Cubism2MotionManager:::cubism2 class Cubism4MotionManager:::cubism4 class Cubism2ExpressionManager:::cubism2 class Cubism4ExpressionManager:::cubism4 InternalModel <|-- Cubism2InternalModel InternalModel <|-- Cubism4InternalModel ModelSettings <|-- Cubism2ModelSettings ModelSettings <|-- Cubism4ModelSettings MotionManager <|-- Cubism2MotionManager MotionManager <|-- Cubism4MotionManager ExpressionManager <|-- Cubism2ExpressionManager ExpressionManager <|-- Cubism4ExpressionManager Live2DModel *-- InternalModel Cubism2InternalModel *-- Live2DModelWebGL Cubism4InternalModel *-- CubismModel InternalModel *-- ModelSettings InternalModel *-- MotionManager MotionManager *-- ExpressionManager InternalModel *-- FocusController Creating model \u00b6 Models can be created by an async method: Live2DModel.from(source, options) . Source \u00b6 Source can be one of the following types: A URL of the model settings file, which typically ends with .model.json (Cubism 2) or .model3.json (Cubism 3/4). const model = await Live2DModel . from ( 'path/to/shizuku.model.json' ); A JSON object of the model settings. Note that you still need to specify the URL by a url property of the JSON object, it's for the resource loaders to know where to load files from. const url = 'path/to/shizuku.model.json' ; const json = await fetch ( url ). then (( res ) => res . json ()); json . url = url ; const model = await Live2DModel . from ( json ); An instance of ModelSettings . Specifically, either Cubism2ModelSettings or Cubism4ModelSettings . const url = 'path/to/shizuku.model.json' ; const json = await fetch ( url ). then (( res ) => res . json ()); json . url = url ; const settings = new Cubism2ModelSettings ( json ); const model = await Live2DModel . from ( settings ); Note URL is required in all cases, because resource loaders rely on the model's URL to resolve its resource files. For example, for a model with URL path/to/shizuku.model.json , its texture image textures/01.png will be resolved to path/to/textures/01.png . Options \u00b6 options is a combination of the options for multiple components, see Live2DFactoryOptions . Creating model synchronously \u00b6 In case you want to participate in the creation, there's a synchronous creation method: Live2DModel.fromSync(source, options) . This method immediately returns a Live2DModel instance, whose resources have not been loaded yet. That means you can't manipulate or render this model - until the load event has been emitted. // no `await` here since it's not a Promise const model = Live2DModel . fromSync ( 'shizuku.model.json' , { onError : console . warn }); // these will cause errors! // app.stage.addChild(model); // model.motion('tap_body'); model . once ( 'load' , () => { // now it's safe app . stage . addChild ( model ); model . motion ( 'tap_body' ); }); With this method, you're able to do extra works when certain resources have been loaded. const model = Live2DModel . fromSync ( 'shizuku.model.json' ); model . once ( 'settingsJSONLoaded' , ( json ) => { // e.g. customize the layout before it's applied to the model json . layout = { ... json . layout , width : 2 , height : 2 , }; }); model . once ( 'settingsLoaded' , ( settings ) => { // e.g. set another URL to the model settings . url = 'alternative/path/to/model' ; }); When all essential resources have been loaded, a ready event is emitted. Then it's safe to render this model if you want it to show up as soon as possible. After that, when all resources, including the optional resources, have been loaded, a load event is emitted. const model = Live2DModel . fromSync ( 'shizuku.model.json' ); model . once ( 'ready' , () => { // now it's safe to display the model, though not recommended because // it's likely to look weird due to missing optional resources app . stage . addChild ( model ); model . motion ( 'tap_body' ); }); The following diagram represents the procedure of model creation. flowchart TD subgraph middlewares urlToJSON jsonToSettings setupOptionals setupEssentials createInternalModel end fromSync([\"Live2DModel.from(source)\"]) source{Type of source?} URL[/URL/] JSON[/JSON/] subgraph Live2DModel ModelSettings[/ModelSettings/] Texture[/\"Texture[]\"/] InternalModel[/InternalModel/] subgraph \"(Optional)\" Pose[/Pose/] Physics[/Physics/] end end urlToJSON ==> jsonToSettings ==> setupOptionals ==> setupEssentials ==> createInternalModel fromSync --> source source --> URL --> urlToJSON source --> JSON --> jsonToSettings source --> ModelSettings ModelSettings --> setupOptionals urlToJSON -.-> |\"#quot;settingsJSONLoaded#quot;\"| JSON jsonToSettings -.-> |\"#quot;settingsLoaded#quot;\"| ModelSettings setupOptionals -.-> |\"#quot;poseLoaded#quot;\"| Pose setupOptionals -.-> |\"#quot;physicsLoaded#quot;\"| Physics setupEssentials -.-> |\"#quot;textureLoaded#quot;\"| Texture createInternalModel -.-> |\"#quot;modelLoaded#quot;\"| InternalModel fromSync --> new[\"new Live2DModel()\"] ------> Live2DModel Live2DModel --> isReady{All but optional resources loaded?} --> |\"#quot;ready#quot;\"| isLoaded{All resources loaded?} --> |\"#quot;loaded#quot;\"| Finish([Finish]) Updating a model \u00b6 To make a Live2D model \"live\", it needs to be updated at every frame. This is done by calling model.update(deltaTime) and there are two ways to do it. Updating automatically \u00b6 This is the default behavior. Model will use PIXI.Ticker.shared to automatically update themselves. The easiest way to achieve this is to import a full build of Pixi and expose PIXI to global scope, so that the model can access Ticker from window.PIXI.Ticker : import * as PIXI from 'pixi.js' ; window . PIXI = PIXI ; Otherwise, you need to manually register the Ticker and TickerPlugin : import { Application } from '@pixi/app' ; import { Ticker , TickerPlugin } from '@pixi/ticker' ; Application . registerPlugin ( TickerPlugin ); Live2DModel . registerTicker ( Ticker ); Updating manually \u00b6 To manually update the model, you need to first disable the autoUpdate option, and then call model.update(deltaTime) at every frame. Using Ticker: import { Ticker } from '@pixi/ticker' ; const model = await Live2DModel . from ( 'shizuku.model.json' , { autoUpdate : false }); const ticker = new Ticker (); ticker . add (() => model . update ( ticker . elapsedMS )); Using requestAnimationFrame() : const model = await Live2DModel . from ( 'shizuku.model.json' , { autoUpdate : false }); let then = performance . now (); function tick ( now ) { model . update ( now - then ); then = now ; requestAnimationFrame ( tick ); } requestAnimationFrame ( tick );","title":"Models"},{"location":"models/#class-diagram","text":"Tip Zoom in the webpage if diagram is too small. classDiagram direction LR class Live2DModel{ internalModel: InternalModel } class InternalModel{ <<abstract>> coreModel: unknown settings: ModelSettings motionManager: MotionManager focusController: FocusController } class ModelSettings{ <<abstract>> } class MotionManager{ <<abstract>> expressionManager: ExpressionManager } class ExpressionManager{ <<abstract>> } class FocusController class Live2DModelWebGL:::cubism2 class CubismModel:::cubism4 class Cubism2InternalModel:::cubism2{ coreModel: Live2DModelWebGL } class Cubism4InternalModel:::cubism4{ coreModel: CubismModel } class Cubism2ModelSettings:::cubism2 class Cubism4ModelSettings:::cubism4 class Cubism2MotionManager:::cubism2 class Cubism4MotionManager:::cubism4 class Cubism2ExpressionManager:::cubism2 class Cubism4ExpressionManager:::cubism4 InternalModel <|-- Cubism2InternalModel InternalModel <|-- Cubism4InternalModel ModelSettings <|-- Cubism2ModelSettings ModelSettings <|-- Cubism4ModelSettings MotionManager <|-- Cubism2MotionManager MotionManager <|-- Cubism4MotionManager ExpressionManager <|-- Cubism2ExpressionManager ExpressionManager <|-- Cubism4ExpressionManager Live2DModel *-- InternalModel Cubism2InternalModel *-- Live2DModelWebGL Cubism4InternalModel *-- CubismModel InternalModel *-- ModelSettings InternalModel *-- MotionManager MotionManager *-- ExpressionManager InternalModel *-- FocusController","title":"Class diagram"},{"location":"models/#creating-model","text":"Models can be created by an async method: Live2DModel.from(source, options) .","title":"Creating model"},{"location":"models/#source","text":"Source can be one of the following types: A URL of the model settings file, which typically ends with .model.json (Cubism 2) or .model3.json (Cubism 3/4). const model = await Live2DModel . from ( 'path/to/shizuku.model.json' ); A JSON object of the model settings. Note that you still need to specify the URL by a url property of the JSON object, it's for the resource loaders to know where to load files from. const url = 'path/to/shizuku.model.json' ; const json = await fetch ( url ). then (( res ) => res . json ()); json . url = url ; const model = await Live2DModel . from ( json ); An instance of ModelSettings . Specifically, either Cubism2ModelSettings or Cubism4ModelSettings . const url = 'path/to/shizuku.model.json' ; const json = await fetch ( url ). then (( res ) => res . json ()); json . url = url ; const settings = new Cubism2ModelSettings ( json ); const model = await Live2DModel . from ( settings ); Note URL is required in all cases, because resource loaders rely on the model's URL to resolve its resource files. For example, for a model with URL path/to/shizuku.model.json , its texture image textures/01.png will be resolved to path/to/textures/01.png .","title":"Source"},{"location":"models/#options","text":"options is a combination of the options for multiple components, see Live2DFactoryOptions .","title":"Options"},{"location":"models/#creating-model-synchronously","text":"In case you want to participate in the creation, there's a synchronous creation method: Live2DModel.fromSync(source, options) . This method immediately returns a Live2DModel instance, whose resources have not been loaded yet. That means you can't manipulate or render this model - until the load event has been emitted. // no `await` here since it's not a Promise const model = Live2DModel . fromSync ( 'shizuku.model.json' , { onError : console . warn }); // these will cause errors! // app.stage.addChild(model); // model.motion('tap_body'); model . once ( 'load' , () => { // now it's safe app . stage . addChild ( model ); model . motion ( 'tap_body' ); }); With this method, you're able to do extra works when certain resources have been loaded. const model = Live2DModel . fromSync ( 'shizuku.model.json' ); model . once ( 'settingsJSONLoaded' , ( json ) => { // e.g. customize the layout before it's applied to the model json . layout = { ... json . layout , width : 2 , height : 2 , }; }); model . once ( 'settingsLoaded' , ( settings ) => { // e.g. set another URL to the model settings . url = 'alternative/path/to/model' ; }); When all essential resources have been loaded, a ready event is emitted. Then it's safe to render this model if you want it to show up as soon as possible. After that, when all resources, including the optional resources, have been loaded, a load event is emitted. const model = Live2DModel . fromSync ( 'shizuku.model.json' ); model . once ( 'ready' , () => { // now it's safe to display the model, though not recommended because // it's likely to look weird due to missing optional resources app . stage . addChild ( model ); model . motion ( 'tap_body' ); }); The following diagram represents the procedure of model creation. flowchart TD subgraph middlewares urlToJSON jsonToSettings setupOptionals setupEssentials createInternalModel end fromSync([\"Live2DModel.from(source)\"]) source{Type of source?} URL[/URL/] JSON[/JSON/] subgraph Live2DModel ModelSettings[/ModelSettings/] Texture[/\"Texture[]\"/] InternalModel[/InternalModel/] subgraph \"(Optional)\" Pose[/Pose/] Physics[/Physics/] end end urlToJSON ==> jsonToSettings ==> setupOptionals ==> setupEssentials ==> createInternalModel fromSync --> source source --> URL --> urlToJSON source --> JSON --> jsonToSettings source --> ModelSettings ModelSettings --> setupOptionals urlToJSON -.-> |\"#quot;settingsJSONLoaded#quot;\"| JSON jsonToSettings -.-> |\"#quot;settingsLoaded#quot;\"| ModelSettings setupOptionals -.-> |\"#quot;poseLoaded#quot;\"| Pose setupOptionals -.-> |\"#quot;physicsLoaded#quot;\"| Physics setupEssentials -.-> |\"#quot;textureLoaded#quot;\"| Texture createInternalModel -.-> |\"#quot;modelLoaded#quot;\"| InternalModel fromSync --> new[\"new Live2DModel()\"] ------> Live2DModel Live2DModel --> isReady{All but optional resources loaded?} --> |\"#quot;ready#quot;\"| isLoaded{All resources loaded?} --> |\"#quot;loaded#quot;\"| Finish([Finish])","title":"Creating model synchronously"},{"location":"models/#updating-a-model","text":"To make a Live2D model \"live\", it needs to be updated at every frame. This is done by calling model.update(deltaTime) and there are two ways to do it.","title":"Updating a model"},{"location":"models/#updating-automatically","text":"This is the default behavior. Model will use PIXI.Ticker.shared to automatically update themselves. The easiest way to achieve this is to import a full build of Pixi and expose PIXI to global scope, so that the model can access Ticker from window.PIXI.Ticker : import * as PIXI from 'pixi.js' ; window . PIXI = PIXI ; Otherwise, you need to manually register the Ticker and TickerPlugin : import { Application } from '@pixi/app' ; import { Ticker , TickerPlugin } from '@pixi/ticker' ; Application . registerPlugin ( TickerPlugin ); Live2DModel . registerTicker ( Ticker );","title":"Updating automatically"},{"location":"models/#updating-manually","text":"To manually update the model, you need to first disable the autoUpdate option, and then call model.update(deltaTime) at every frame. Using Ticker: import { Ticker } from '@pixi/ticker' ; const model = await Live2DModel . from ( 'shizuku.model.json' , { autoUpdate : false }); const ticker = new Ticker (); ticker . add (() => model . update ( ticker . elapsedMS )); Using requestAnimationFrame() : const model = await Live2DModel . from ( 'shizuku.model.json' , { autoUpdate : false }); let then = performance . now (); function tick ( now ) { model . update ( now - then ); then = now ; requestAnimationFrame ( tick ); } requestAnimationFrame ( tick );","title":"Updating manually"},{"location":"motions_expressions/","text":"Motions are managed by the MotionManager of each model. Idle motions \u00b6 When the model is not playing any motion, it's considered idle , and then its motion manager will randomly start an idle motion as \"idle\" priority. Idle motions refer to the ones defined in a dedicated motion group: \"idle\" on Cubism 2, and \"Idle\" on Cubism 4. But you can specify a custom group to read idle motions from: model . internalModel . motionManager . groups . idle = 'main_idle' ; You can also specify it when creating the model, in order to preload this group according to the preload strategy. const model = await Live2DModel . from ( 'shizuku.model.json' , { idleMotionGroup : 'main_idle' }); Preloading motions \u00b6 Motions are separate files and will be lazy loaded, so when you start a motion for the first time, it will be fetched from server. Depending on the network speed, this may cause a noticeable delay. Motion preloading is here to help. It preloads motion during model creation to ensure motions can be played seamlessly (except for the first played motion because it may not have been loaded as soon as the model creation completes). By default, only idle motions will be preloaded. You can change this by setting the motionPreload option. import { MotionPreloadStrategy } from 'pixi-live2d-display' ; // MotionPreloadStrategy.ALL // MotionPreloadStrategy.IDLE // MotionPreloadStrategy.NONE const model = await Live2DModel . from ( 'shizuku.model.json' , { motionPreload : MotionPreloadStrategy . NONE }); Caution Be careful of using MotionPreloadStrategy.ALL . Loading too many motions at the same time will send a lot of HTTP requests that may block the network from loading other resources due to the browser's concurrent connection limit. Starting Motions \u00b6 // start the first motion in \"tap_body\" group model . motion ( 'tap_body' , 0 ); // start a random motion in \"tap_body\" group model . motion ( 'tap_body' ); // the above calls are shorthands of these methods model . internalModel . motionManager . startMotion ( 'tap_body' , 0 ); model . internalModel . motionManager . startRandomMotion ( 'tap_body' ); These methods return a Promise that resolves with true when the motion is successfully started, and false otherwise. Priorities \u00b6 A motion can be started as one of these priorities: IDLE , NORMAL and FORCE . IDLE : Low priority. Each model typically has a set of idle motions, which will be automatically played as such priority when the model is idle. NORMAL : Medium priority. This is the default value if you don't provide one. FORCE : High priority. This makes sure the motion will always be played regardless of the current priority, except for meeting a race condition where a subsequent motion with the same priority is loaded before this motion. NONE : No priority. This cannot be assigned to a motion, it's internally used to represent the state that there's no any motion playing. import { MotionPriority } from 'pixi-live2d-display' ; model . motion ( 'tap_body' , 0 , MotionPriority . NORMAL ); // start a random motion model . motion ( 'tap_body' , undefined , MotionPriority . NORMAL ); State management \u00b6 If a motion is requested to play when there's already another motion playing, then the current motion will not be canceled immediately, instead, the new motion reserves the place and starts to load, and the current motion will keep playing until the new motion has been loaded. The actual rules are a bit more complicated, below is a state-transition table specifying that which motion will eventually be played when attempting to start a motion in a particular situation, assuming the loading will never fail and will be finished in a relatively short time. When: Start motion C as: NONE IDLE NORMAL FORCE Playing none Reserved none none C C C Playing A as IDLE Reserved none A A C C Playing A as NORMAL Reserved none A A A C Playing A as FORCE Reserved none A A A C Playing A as IDLE Reserved B as NORMAL B B B C Playing A as NORMAL Reserved B as FORCE B B B C Playing A as FORCE Reserved B as FORCE B B B C Playing none Reserved B as IDLE B B C C Playing none Reserved B as FORCE B B B C Playing none Reserved B as FORCE B B B C Note that these rules are different with Live2D's official samples in some cases: Race conditions will be correctly handled. Playing motions in parallel is not yet supported. Sounds \u00b6 If the motion is specified with a sound file, it'll be played together with this motion. <audio> elements are all managed by the singleton SoundManager . During playback, you can access those audios from SoundManager.audios . You can also set a global volume to all active audios, and it will also affect audios created in the future. import { SoundManager } from 'pixi-live2d-display' ; SoundManager . volume = 0.5 ; To handle the audios separately, you can listen for the motionStart event. model . internalModel . motionManager . on ( 'motionStart' , ( group , index , audio ) => { if ( audio ) { // e.g. show subtitle for this audio showSubtitle ( group , index ); audio . addEventListener ( 'ended' , () => dismissSubtitle ()); } }); Motion Sync \u00b6 There are two concurrent tasks while starting a motion with sound: flowchart LR A[Load motion] --> B[Play motion] C[Load sound] --> D[Play sound] This can easily cause the sound to be out of sync with the motion because they are not always going to be loaded at the same time. With motion sync, playbacks will be deferred until both the motion and sound have been loaded, looking like this: flowchart LR A[Load motion] & C[Load sound] --> B[Wait until both are done] --> D[Play motion and sound] This feature is enabled by default and can be toggled via global config . Expressions \u00b6 Expressions are managed by ExpressionManager inside MotionManager . // apply the first expression model . expression ( 0 ); // apply the expression named \"smile\" model . expression ( 'smile' ); // when the argument is omitted, it applies a random expression model . expression (); // the above calls are shorthands of these methods model . internalModel . motionManager . expressionManager . setExpression ( 0 ); model . internalModel . motionManager . expressionManager . setExpression ( 'smile' ); model . internalModel . motionManager . expressionManager . setRandomExpression (); Caution If a model has no expression defined in its settings, ExpressionManager will not be created at all, meaning that model.internalModel.motionManager.expressionManager is undefined.","title":"Motions and Expressions"},{"location":"motions_expressions/#idle-motions","text":"When the model is not playing any motion, it's considered idle , and then its motion manager will randomly start an idle motion as \"idle\" priority. Idle motions refer to the ones defined in a dedicated motion group: \"idle\" on Cubism 2, and \"Idle\" on Cubism 4. But you can specify a custom group to read idle motions from: model . internalModel . motionManager . groups . idle = 'main_idle' ; You can also specify it when creating the model, in order to preload this group according to the preload strategy. const model = await Live2DModel . from ( 'shizuku.model.json' , { idleMotionGroup : 'main_idle' });","title":"Idle motions"},{"location":"motions_expressions/#preloading-motions","text":"Motions are separate files and will be lazy loaded, so when you start a motion for the first time, it will be fetched from server. Depending on the network speed, this may cause a noticeable delay. Motion preloading is here to help. It preloads motion during model creation to ensure motions can be played seamlessly (except for the first played motion because it may not have been loaded as soon as the model creation completes). By default, only idle motions will be preloaded. You can change this by setting the motionPreload option. import { MotionPreloadStrategy } from 'pixi-live2d-display' ; // MotionPreloadStrategy.ALL // MotionPreloadStrategy.IDLE // MotionPreloadStrategy.NONE const model = await Live2DModel . from ( 'shizuku.model.json' , { motionPreload : MotionPreloadStrategy . NONE }); Caution Be careful of using MotionPreloadStrategy.ALL . Loading too many motions at the same time will send a lot of HTTP requests that may block the network from loading other resources due to the browser's concurrent connection limit.","title":"Preloading motions"},{"location":"motions_expressions/#starting-motions","text":"// start the first motion in \"tap_body\" group model . motion ( 'tap_body' , 0 ); // start a random motion in \"tap_body\" group model . motion ( 'tap_body' ); // the above calls are shorthands of these methods model . internalModel . motionManager . startMotion ( 'tap_body' , 0 ); model . internalModel . motionManager . startRandomMotion ( 'tap_body' ); These methods return a Promise that resolves with true when the motion is successfully started, and false otherwise.","title":"Starting Motions"},{"location":"motions_expressions/#priorities","text":"A motion can be started as one of these priorities: IDLE , NORMAL and FORCE . IDLE : Low priority. Each model typically has a set of idle motions, which will be automatically played as such priority when the model is idle. NORMAL : Medium priority. This is the default value if you don't provide one. FORCE : High priority. This makes sure the motion will always be played regardless of the current priority, except for meeting a race condition where a subsequent motion with the same priority is loaded before this motion. NONE : No priority. This cannot be assigned to a motion, it's internally used to represent the state that there's no any motion playing. import { MotionPriority } from 'pixi-live2d-display' ; model . motion ( 'tap_body' , 0 , MotionPriority . NORMAL ); // start a random motion model . motion ( 'tap_body' , undefined , MotionPriority . NORMAL );","title":"Priorities"},{"location":"motions_expressions/#state-management","text":"If a motion is requested to play when there's already another motion playing, then the current motion will not be canceled immediately, instead, the new motion reserves the place and starts to load, and the current motion will keep playing until the new motion has been loaded. The actual rules are a bit more complicated, below is a state-transition table specifying that which motion will eventually be played when attempting to start a motion in a particular situation, assuming the loading will never fail and will be finished in a relatively short time. When: Start motion C as: NONE IDLE NORMAL FORCE Playing none Reserved none none C C C Playing A as IDLE Reserved none A A C C Playing A as NORMAL Reserved none A A A C Playing A as FORCE Reserved none A A A C Playing A as IDLE Reserved B as NORMAL B B B C Playing A as NORMAL Reserved B as FORCE B B B C Playing A as FORCE Reserved B as FORCE B B B C Playing none Reserved B as IDLE B B C C Playing none Reserved B as FORCE B B B C Playing none Reserved B as FORCE B B B C Note that these rules are different with Live2D's official samples in some cases: Race conditions will be correctly handled. Playing motions in parallel is not yet supported.","title":"State management"},{"location":"motions_expressions/#sounds","text":"If the motion is specified with a sound file, it'll be played together with this motion. <audio> elements are all managed by the singleton SoundManager . During playback, you can access those audios from SoundManager.audios . You can also set a global volume to all active audios, and it will also affect audios created in the future. import { SoundManager } from 'pixi-live2d-display' ; SoundManager . volume = 0.5 ; To handle the audios separately, you can listen for the motionStart event. model . internalModel . motionManager . on ( 'motionStart' , ( group , index , audio ) => { if ( audio ) { // e.g. show subtitle for this audio showSubtitle ( group , index ); audio . addEventListener ( 'ended' , () => dismissSubtitle ()); } });","title":"Sounds"},{"location":"motions_expressions/#motion-sync","text":"There are two concurrent tasks while starting a motion with sound: flowchart LR A[Load motion] --> B[Play motion] C[Load sound] --> D[Play sound] This can easily cause the sound to be out of sync with the motion because they are not always going to be loaded at the same time. With motion sync, playbacks will be deferred until both the motion and sound have been loaded, looking like this: flowchart LR A[Load motion] & C[Load sound] --> B[Wait until both are done] --> D[Play motion and sound] This feature is enabled by default and can be toggled via global config .","title":"Motion Sync"},{"location":"motions_expressions/#expressions","text":"Expressions are managed by ExpressionManager inside MotionManager . // apply the first expression model . expression ( 0 ); // apply the expression named \"smile\" model . expression ( 'smile' ); // when the argument is omitted, it applies a random expression model . expression (); // the above calls are shorthands of these methods model . internalModel . motionManager . expressionManager . setExpression ( 0 ); model . internalModel . motionManager . expressionManager . setExpression ( 'smile' ); model . internalModel . motionManager . expressionManager . setRandomExpression (); Caution If a model has no expression defined in its settings, ExpressionManager will not be created at all, meaning that model.internalModel.motionManager.expressionManager is undefined.","title":"Expressions"}]}